关于Node.js中使用`exec`创建的子进程是否会自动销毁，简单来说：**当子进程自己正常执行完毕时，它会自动退出；但如果你需要在中途主动终止它，或者主进程异常退出，则需要你手动处理。**

### 🔄 子进程的生命周期管理

为了让你更清晰地了解不同情况，可以参考下表：

| 场景 | 子进程是否会自动退出？ | 说明与建议 |
| :--- | :--- | :--- |
| **子进程正常完成** | ✅ **是** | 任务完成后，子进程自动退出，回调函数被调用。 |
| **中途主动终止** | ❌ **否** | 需要你手动调用 `child.kill()` 或 `child.kill('SIGTERM')` 。也可以发送 `SIGKILL` 等信号。 |
| **主进程先退出** | ❌ **否** | 子进程可能成为"孤儿进程"继续运行。需要在主进程的 `exit` 事件中手动清理。 |
| **输出超过默认限制** | ✅ **是** | 默认 `maxBuffer` 为 200KB。超过此限制，子进程会被自动终止。 |

### 💡 实用代码示例

以下是一些关键操作的代码示例，帮助你更好地理解：

#### 1. 创建并设置超时终止
```javascript
const { exec } = require('child_process');

const child = exec('your-command-here', (error, stdout, stderr) => {
  if (error) {
    console.error(`执行出错: ${error}`);
    return;
  }
  console.log(`输出: ${stdout}`);
});

// 设置一个10秒的超时，如果子进程未完成则终止它
setTimeout(() => {
  // 检查进程是否还在运行
  if (!child.killed) { 
    child.kill();
    console.log('子进程已超时终止');
  }
}, 10000);
```
**说明**：这种方式适用于控制命令的最大执行时间。

#### 2. 主进程退出时清理子进程
```javascript
const { spawn } = require('child_process');
const child = spawn('node', ['child.js']);

// 监听主进程的退出事件，并清理子进程
process.on('exit', () => {
  child.kill();
});
```
**说明**：确保在主进程意外退出时，不会留下残留的子进程。这里使用`spawn`作为示例，`exec`创建的子进程同样适用。

#### 3. 处理输出缓冲区限制
```javascript
const { exec } = require('child_process');

const child = exec('your-command-here', { 
  maxBuffer: 1024 * 1024 // 将缓冲区大小设置为1MB，根据需要调整
}, (error, stdout, stderr) => {
  // 回调函数逻辑
});
```
**说明**：如果你的命令会产生大量输出，记得调整`maxBuffer`选项以避免意外终止。

### ⚠️ 关于`exec`的进阶提醒

- **安全考虑**：`exec`会**启动一个Shell**来解析命令，如果命令字符串中包含用户输入，会有**命令注入的风险**。在需要处理用户输入或对性能要求较高的场景下，更推荐使用默认不启动Shell的 `spawn` 或 `execFile`。

希望这些信息能帮助你更好地管理Node.js中的子进程。如果你对特定场景（例如如何防止命令注入）有进一步的疑问，我很乐意提供更多说明。

# Node.js Stream 与 Child Process 深度详解

## 🌊 **Stream 模块 - 全面深入**

### 核心概念与流类型

#### 四种基本流类型
```javascript
const { Readable, Writable, Duplex, Transform } = require('stream');

// 1. 可读流 (Readable) - 数据源
class MyReadable extends Readable {
    constructor(options) {
        super(options);
        this.data = ['数据块1', '数据块2', '数据块3'];
        this.index = 0;
    }

    _read(size) {
        if (this.index < this.data.length) {
            this.push(this.data[this.index++]);
        } else {
            this.push(null); // 结束流
        }
    }
}

// 2. 可写流 (Writable) - 数据目的地
class MyWritable extends Writable {
    _write(chunk, encoding, callback) {
        console.log(`写入数据: ${chunk.toString()}`);
        callback(); // 必须调用，表示写入完成
    }
}

// 3. 双工流 (Duplex) - 可读可写
class MyDuplex extends Duplex {
    constructor(options) {
        super(options);
        this.data = [];
    }

    _write(chunk, encoding, callback) {
        this.data.push(chunk);
        callback();
    }

    _read(size) {
        if (this.data.length > 0) {
            this.push(this.data.shift());
        } else {
            this.push(null);
        }
    }
}

// 4. 转换流 (Transform) - 数据处理转换
class MyTransform extends Transform {
    _transform(chunk, encoding, callback) {
        const transformed = chunk.toString().toUpperCase();
        this.push(transformed);
        callback();
    }
}
```

### 高级流应用场景

#### 1. 大数据实时分析管道
```javascript
const { pipeline, Transform } = require('stream');
const fs = require('fs');

// 实时日志分析系统
class LogParser extends Transform {
    constructor() {
        super({ objectMode: true }); // 对象模式，处理JS对象而非Buffer
    }

    _transform(chunk, encoding, callback) {
        try {
            const logEntry = chunk.toString();
            const parsed = this.parseLogEntry(logEntry);
            if (parsed) this.push(parsed);
            callback();
        } catch (error) {
            callback(error);
        }
    }

    parseLogEntry(entry) {
        const regex = /\[(.*?)\] (\w+): (.*)/;
        const match = entry.match(regex);
        if (match) {
            return {
                timestamp: new Date(match[1]),
                level: match[2],
                message: match[3],
                processedAt: new Date()
            };
        }
        return null;
    }
}

class LogAnalyzer extends Transform {
    constructor() {
        super({ objectMode: true });
        this.stats = {
            errors: 0,
            warnings: 0,
            infos: 0
        };
    }

    _transform(logObj, encoding, callback) {
        // 实时统计
        if (logObj.level === 'ERROR') this.stats.errors++;
        if (logObj.level === 'WARN') this.stats.warnings++;
        if (logObj.level === 'INFO') this.stats.infos++;

        // 添加分析结果
        logObj.analysis = {
            isError: logObj.level === 'ERROR',
            isRecent: Date.now() - logObj.timestamp < 5 * 60 * 1000,
            stats: { ...this.stats }
        };

        this.push(logObj);
        callback();
    }
}

// 构建完整的数据处理管道
pipeline(
    fs.createReadStream('./app.log', { highWaterMark: 64 * 1024 }), // 64KB缓冲区
    new LogParser(),
    new LogAnalyzer(),
    new Transform({
        objectMode: true,
        transform(logObj, encoding, callback) {
            // 输出到控制台和文件
            console.log('分析结果:', logObj.analysis);
            this.push(JSON.stringify(logObj) + '\n');
            callback();
        }
    }),
    fs.createWriteStream('./analyzed-logs.jsonl'),
    (err) => {
        if (err) {
            console.error('管道处理失败:', err);
        } else {
            console.log('日志分析完成');
        }
    }
);
```

#### 2. 实时视频流处理
```javascript
const { Transform, PassThrough } = require('stream');
const crypto = require('crypto');

// 视频流加密传输系统
class VideoEncryptor extends Transform {
    constructor(password) {
        super();
        this.algorithm = 'aes-256-ctr';
        this.key = crypto.scryptSync(password, 'salt', 32);
        this.iv = crypto.randomBytes(16);
        this.cipher = crypto.createCipheriv(this.algorithm, this.key, this.iv);
        
        // 首先发送IV
        this.push(this.iv);
    }

    _transform(chunk, encoding, callback) {
        try {
            const encrypted = this.cipher.update(chunk);
            this.push(encrypted);
            callback();
        } catch (error) {
            callback(error);
        }
    }

    _flush(callback) {
        try {
            const finalBlock = this.cipher.final();
            this.push(finalBlock);
            callback();
        } catch (error) {
            callback(error);
        }
    }
}

class VideoStreamProcessor extends Duplex {
    constructor(options) {
        super(options);
        this.buffers = [];
        this.processing = false;
    }

    _write(chunk, encoding, callback) {
        this.buffers.push(chunk);
        if (!this.processing) {
            this.processBuffers();
        }
        callback();
    }

    _read(size) {
        // 数据通过push方法提供
    }

    async processBuffers() {
        this.processing = true;
        
        while (this.buffers.length > 0) {
            const chunk = this.buffers.shift();
            
            // 模拟视频处理：添加水印、调整质量等
            const processed = await this.processVideoChunk(chunk);
            
            if (!this.push(processed)) {
                // 如果消费者跟不上，暂停处理
                break;
            }
        }
        
        this.processing = false;
    }

    async processVideoChunk(chunk) {
        // 模拟异步视频处理
        return new Promise(resolve => {
            setTimeout(() => {
                // 在实际应用中，这里可能是FFmpeg处理、水印添加等
                const processed = Buffer.concat([
                    Buffer.from(`[FRAME:${Date.now()}]`),
                    chunk
                ]);
                resolve(processed);
            }, 10);
        });
    }
}

// 使用示例：视频流加密传输
function createSecureVideoStream(inputPath, password) {
    const videoStream = fs.createReadStream(inputPath);
    const encryptor = new VideoEncryptor(password);
    const processor = new VideoStreamProcessor();
    
    return videoStream.pipe(processor).pipe(encryptor);
}
```

#### 3. 数据库流式导入导出
```javascript
const { Transform } = require('stream');
const { MongoClient } = require('mongodb');

class MongoExporter extends Readable {
    constructor(collection, query = {}, batchSize = 1000) {
        super({ objectMode: true });
        this.collection = collection;
        this.query = query;
        this.batchSize = batchSize;
        this.cursor = null;
        this.isReading = false;
    }

    async _read(size) {
        if (this.isReading) return;
        
        this.isReading = true;
        
        if (!this.cursor) {
            this.cursor = this.collection.find(this.query).batchSize(this.batchSize);
        }
        
        try {
            let count = 0;
            while (await this.cursor.hasNext() && count < size) {
                const doc = await this.cursor.next();
                if (!this.push(doc)) {
                    break;
                }
                count++;
            }
            
            if (!await this.cursor.hasNext()) {
                this.push(null); // 结束流
                await this.cursor.close();
            }
        } catch (error) {
            this.destroy(error);
        }
        
        this.isReading = false;
    }
}

class DataTransformer extends Transform {
    constructor(transformFn) {
        super({ objectMode: true });
        this.transformFn = transformFn;
    }

    async _transform(chunk, encoding, callback) {
        try {
            const transformed = await this.transformFn(chunk);
            if (transformed) {
                this.push(transformed);
            }
            callback();
        } catch (error) {
            callback(error);
        }
    }
}

// 使用示例：大数据导出和转换
async function exportAndTransformData() {
    const client = await MongoClient.connect('mongodb://localhost:27017');
    const db = client.db('mydb');
    const collection = db.collection('large_dataset');
    
    const exporter = new MongoExporter(collection, { status: 'active' });
    const transformer = new DataTransformer(async (doc) => {
        // 数据清洗和转换
        return {
            id: doc._id.toString(),
            name: doc.name.trim(),
            email: doc.email.toLowerCase(),
            createdAt: new Date(),
            metadata: {
                original: doc,
                processedBy: 'stream-pipeline'
            }
        };
    });
    
    return exporter.pipe(transformer);
}
```

## 👶 **Child Process 模块 - 全面深入**

### 进程创建方式对比

| 方法 | 使用场景 | 特点 | 返回值 |
|------|----------|------|---------|
| `exec` | 执行Shell命令 | 缓冲输出，适合小量数据 | Buffer |
| `execFile` | 执行可执行文件 | 不启动Shell，更安全 | Buffer |
| `spawn` | 长时间运行进程 | 流式I/O，适合大量数据 | Stream |
| `fork` | Node.js模块 | 特殊spawn，IPC通信 | 子进程对象 |

### 高级进程管理

#### 1. 进程池管理系统
```javascript
const { fork } = require('child_process');
const path = require('path');
const EventEmitter = require('events');

class ProcessPool extends EventEmitter {
    constructor(scriptPath, poolSize = 4) {
        super();
        this.scriptPath = scriptPath;
        this.poolSize = poolSize;
        this.availableWorkers = [];
        this.busyWorkers = new Map();
        this.taskQueue = [];
        this.workerIdCounter = 0;

        this.initializeWorkers();
    }

    initializeWorkers() {
        for (let i = 0; i < this.poolSize; i++) {
            this.createWorker();
        }
    }

    createWorker() {
        const worker = fork(this.scriptPath, [], {
            stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
            execArgv: ['--max-old-space-size=4096'] // 4GB内存限制
        });

        const workerId = this.workerIdCounter++;
        
        worker.workerId = workerId;
        worker.available = true;

        worker.on('message', (result) => {
            this.handleWorkerResult(worker, result);
        });

        worker.on('error', (error) => {
            console.error(`Worker ${workerId} 错误:`, error);
            this.restartWorker(worker);
        });

        worker.on('exit', (code, signal) => {
            console.log(`Worker ${workerId} 退出，代码: ${code}, 信号: ${signal}`);
            if (code !== 0) {
                this.restartWorker(worker);
            }
        });

        // 监控内存使用
        setInterval(() => {
            if (worker.connected) {
                worker.send({ type: 'STATUS_REQUEST' });
            }
        }, 30000);

        this.availableWorkers.push(worker);
        this.emit('workerCreated', workerId);
    }

    executeTask(taskData, timeout = 30000) {
        return new Promise((resolve, reject) => {
            const task = {
                data: taskData,
                resolve,
                reject,
                timeoutId: null
            };

            // 设置超时
            if (timeout > 0) {
                task.timeoutId = setTimeout(() => {
                    const index = this.taskQueue.indexOf(task);
                    if (index > -1) {
                        this.taskQueue.splice(index, 1);
                    }
                    reject(new Error(`任务执行超时 (${timeout}ms)`));
                }, timeout);
            }

            this.taskQueue.push(task);
            this.processNextTask();
        });
    }

    processNextTask() {
        if (this.taskQueue.length === 0 || this.availableWorkers.length === 0) {
            return;
        }

        const task = this.taskQueue.shift();
        const worker = this.availableWorkers.pop();

        if (task.timeoutId) {
            clearTimeout(task.timeoutId);
        }

        worker.available = false;
        this.busyWorkers.set(worker.workerId, { worker, task });

        try {
            worker.send({
                type: 'EXECUTE_TASK',
                data: task.data,
                taskId: Date.now() + Math.random()
            });

            this.emit('taskStarted', worker.workerId, task.data);
        } catch (error) {
            task.reject(error);
            this.releaseWorker(worker);
        }
    }

    handleWorkerResult(worker, result) {
        const busyWorker = this.busyWorkers.get(worker.workerId);
        if (!busyWorker) return;

        const { task } = busyWorker;

        if (result.type === 'TASK_RESULT') {
            task.resolve(result.data);
            this.emit('taskCompleted', worker.workerId, result.data);
        } else if (result.type === 'TASK_ERROR') {
            task.reject(new Error(result.error));
            this.emit('taskFailed', worker.workerId, result.error);
        } else if (result.type === 'STATUS_RESPONSE') {
            this.emit('workerStatus', worker.workerId, result.data);
            return; // 状态响应不释放worker
        }

        this.busyWorkers.delete(worker.workerId);
        this.releaseWorker(worker);
    }

    releaseWorker(worker) {
        worker.available = true;
        this.availableWorkers.push(worker);
        this.processNextTask();
    }

    restartWorker(worker) {
        const index = this.availableWorkers.indexOf(worker);
        if (index > -1) {
            this.availableWorkers.splice(index, 1);
        }
        this.busyWorkers.delete(worker.workerId);
        
        if (worker.connected) {
            worker.kill('SIGTERM');
        }
        
        setTimeout(() => this.createWorker(), 1000);
    }

    async drain() {
        // 等待所有任务完成
        while (this.busyWorkers.size > 0 || this.taskQueue.length > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        // 终止所有worker
        this.availableWorkers.forEach(worker => {
            if (worker.connected) {
                worker.kill('SIGTERM');
            }
        });
        
        this.availableWorkers = [];
        this.busyWorkers.clear();
    }
}

// 使用示例
const pool = new ProcessPool('./worker-script.js', 4);

// 监控事件
pool.on('workerCreated', (workerId) => {
    console.log(`Worker ${workerId} 已创建`);
});

pool.on('taskStarted', (workerId, taskData) => {
    console.log(`Worker ${workerId} 开始处理任务`);
});

// 执行任务
async function processMultipleTasks() {
    const tasks = [
        { type: 'image_processing', file: 'image1.jpg' },
        { type: 'data_analysis', dataset: 'large.csv' },
        { type: 'video_encoding', video: 'video.mp4' }
    ];

    const results = await Promise.allSettled(
        tasks.map(task => pool.executeTask(task, 60000))
    );

    return results;
}
```

#### 2. 实时进程监控和自动恢复
```javascript
const { spawn } = require('child_process');
const os = require('os');

class MonitoredProcess {
    constructor(command, args = [], options = {}) {
        this.command = command;
        this.args = args;
        this.options = { 
            stdio: ['pipe', 'pipe', 'pipe'],
            ...options 
        };
        
        this.process = null;
        this.restartCount = 0;
        this.maxRestarts = 5;
        this.restartDelay = 1000;
        this.metrics = {
            startTime: null,
            cpuUsage: 0,
            memoryUsage: 0,
            outputSize: 0
        };
        
        this.start();
    }

    start() {
        this.process = spawn(this.command, this.args, this.options);
        this.metrics.startTime = new Date();
        
        console.log(`进程启动: ${this.command} ${this.args.join(' ')}`);

        // 标准输出处理
        this.process.stdout.on('data', (data) => {
            this.metrics.outputSize += data.length;
            console.log(`[STDOUT] ${data.toString().trim()}`);
        });

        // 错误输出处理
        this.process.stderr.on('data', (data) => {
            console.error(`[STDERR] ${data.toString().trim()}`);
        });

        // 进程退出处理
        this.process.on('exit', (code, signal) => {
            console.log(`进程退出，代码: ${code}, 信号: ${signal}`);
            this.handleExit(code, signal);
        });

        this.process.on('error', (error) => {
            console.error(`进程错误: ${error.message}`);
            this.handleExit(1, null);
        });

        // 开始监控
        this.startMonitoring();
    }

    handleExit(code, signal) {
        if (code === 0 || signal === 'SIGTERM') {
            console.log('进程正常退出');
            return;
        }

        if (this.restartCount < this.maxRestarts) {
            this.restartCount++;
            console.log(`准备重启进程 (${this.restartCount}/${this.maxRestarts})...`);
            
            setTimeout(() => {
                this.start();
            }, this.restartDelay * this.restartCount); // 递增延迟
        } else {
            console.error('达到最大重启次数，停止重启');
            this.emit('failed');
        }
    }

    startMonitoring() {
        this.monitorInterval = setInterval(() => {
            if (this.process && this.process.pid) {
                this.collectMetrics();
            }
        }, 5000);
    }

    collectMetrics() {
        // 收集进程指标
        try {
            const memoryUsage = process.memoryUsage();
            this.metrics.memoryUsage = memoryUsage.rss;
            this.metrics.cpuUsage = process.cpuUsage();
            
            // 检查资源使用情况
            if (memoryUsage.rss > 500 * 1024 * 1024) { // 500MB
                console.warn('进程内存使用过高:', memoryUsage.rss);
            }
        } catch (error) {
            console.error('收集指标失败:', error);
        }
    }

    sendCommand(command) {
        if (this.process && this.process.stdin.writable) {
            this.process.stdin.write(command + '\n');
            return true;
        }
        return false;
    }

    gracefulShutdown() {
        clearInterval(this.monitorInterval);
        
        if (this.process) {
            this.process.kill('SIGTERM');
            
            // 强制关闭超时
            setTimeout(() => {
                if (this.process) {
                    this.process.kill('SIGKILL');
                }
            }, 10000);
        }
    }

    getStatus() {
        return {
            pid: this.process ? this.process.pid : null,
            running: this.process !== null,
            restartCount: this.restartCount,
            metrics: this.metrics,
            uptime: this.metrics.startTime ? 
                Date.now() - this.metrics.startTime.getTime() : 0
        };
    }
}

// 使用示例：监控关键服务
const nginxProcess = new MonitoredProcess('nginx', ['-g', 'daemon off;'], {
    cwd: '/etc/nginx',
    env: { ...process.env, NGINX_ENV: 'production' }
});

// 创建监控接口
const http = require('http');
const server = http.createServer((req, res) => {
    if (req.url === '/status') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(nginxProcess.getStatus()));
    } else if (req.url === '/restart' && req.method === 'POST') {
        nginxProcess.gracefulShutdown();
        res.end('重启指令已发送');
    }
});

server.listen(8080);
```

#### 3. 分布式任务处理系统
```javascript
const { Worker } = require('worker_threads');
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

class DistributedTaskSystem {
    constructor() {
        this.workers = new Map();
        this.taskQueue = [];
        this.completedTasks = new Map();
        this.isMaster = cluster.isMaster;
        
        if (this.isMaster) {
            this.setupMaster();
        } else {
            this.setupWorker();
        }
    }

    setupMaster() {
        console.log(`主进程 ${process.pid} 启动`);

        // 创建工作进程
        for (let i = 0; i < numCPUs; i++) {
            const worker = cluster.fork();
            
            worker.on('message', (message) => {
                this.handleWorkerMessage(worker, message);
            });

            this.workers.set(worker.id, {
                process: worker,
                busy: false,
                currentTask: null
            });
        }

        cluster.on('exit', (worker, code, signal) => {
            console.log(`工作进程 ${worker.process.pid} 退出`);
            this.workers.delete(worker.id);
            
            // 自动重启
            setTimeout(() => {
                const newWorker = cluster.fork();
                this.workers.set(newWorker.id, {
                    process: newWorker,
                    busy: false,
                    currentTask: null
                });
            }, 1000);
        });

        // 开始处理任务
        this.processTaskQueue();
    }

    setupWorker() {
        // 工作进程准备接收任务
        process.on('message', async (message) => {
            if (message.type === 'EXECUTE_TASK') {
                try {
                    const result = await this.executeTask(message.task);
                    process.send({
                        type: 'TASK_COMPLETED',
                        taskId: message.taskId,
                        result: result
                    });
                } catch (error) {
                    process.send({
                        type: 'TASK_FAILED',
                        taskId: message.taskId,
                        error: error.message
                    });
                }
            }
        });
    }

    async executeTask(task) {
        // 根据任务类型执行不同的处理逻辑
        switch (task.type) {
            case 'DATA_PROCESSING':
                return await this.processData(task.data);
            case 'IMAGE_PROCESSING':
                return await this.processImage(task.data);
            case 'ML_INFERENCE':
                return await this.runMLInference(task.data);
            default:
                throw new Error(`未知任务类型: ${task.type}`);
        }
    }

    async processData(data) {
        // 模拟数据处理
        return new Promise(resolve => {
            setTimeout(() => {
                resolve({
                    processed: true,
                    records: data.length,
                    timestamp: new Date()
                });
            }, 1000);
        });
    }

    submitTask(task, priority = 0) {
        const taskId = this.generateTaskId();
        const taskItem = {
            id: taskId,
            task: task,
            priority: priority,
            submittedAt: new Date(),
            status: 'pending'
        };

        // 根据优先级插入队列
        const index = this.taskQueue.findIndex(t => t.priority < priority);
        if (index === -1) {
            this.taskQueue.push(taskItem);
        } else {
            this.taskQueue.splice(index, 0, taskItem);
        }

        return taskId;
    }

    processTaskQueue() {
        setInterval(() => {
            if (this.taskQueue.length === 0) return;

            // 查找空闲worker
            const availableWorker = Array.from(this.workers.values())
                .find(w => !w.busy);

            if (availableWorker) {
                const task = this.taskQueue.shift();
                availableWorker.busy = true;
                availableWorker.currentTask = task;

                availableWorker.process.send({
                    type: 'EXECUTE_TASK',
                    taskId: task.id,
                    task: task.task
                });

                task.status = 'processing';
                console.log(`任务 ${task.id} 分配给工作进程 ${availableWorker.process.id}`);
            }
        }, 100);
    }

    handleWorkerMessage(worker, message) {
        const workerInfo = this.workers.get(worker.id);
        
        switch (message.type) {
            case 'TASK_COMPLETED':
                workerInfo.busy = false;
                workerInfo.currentTask.status = 'completed';
                
                this.completedTasks.set(message.taskId, {
                    result: message.result,
                    completedAt: new Date()
                });
                
                console.log(`任务 ${message.taskId} 完成`);
                break;

            case 'TASK_FAILED':
                workerInfo.busy = false;
                workerInfo.currentTask.status = 'failed';
                
                console.error(`任务 ${message.taskId} 失败:`, message.error);
                break;
        }
    }

    generateTaskId() {
        return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    getSystemStatus() {
        return {
            totalWorkers: this.workers.size,
            busyWorkers: Array.from(this.workers.values()).filter(w => w.busy).length,
            pendingTasks: this.taskQueue.length,
            completedTasks: this.completedTasks.size,
            workers: Array.from(this.workers.values()).map(w => ({
                id: w.process.id,
                busy: w.busy,
                currentTask: w.currentTask ? w.currentTask.id : null
            }))
        };
    }
}

// 使用示例
if (cluster.isMaster) {
    const taskSystem = new DistributedTaskSystem();
    
    // 提交多个任务
    for (let i = 0; i < 100; i++) {
        taskSystem.submitTask({
            type: 'DATA_PROCESSING',
            data: Array(1000).fill(i).map((val, idx) => ({ id: idx, value: val }))
        }, Math.floor(Math.random() * 3));
    }
    
    // 监控系统状态
    setInterval(() => {
        console.log('系统状态:', taskSystem.getSystemStatus());
    }, 5000);
}
```

### 性能优化和最佳实践

#### 1. 流式处理的最佳实践
```javascript
// 错误处理
function createRobustStreamPipeline() {
    const { pipeline } = require('stream');
    const { promisify } = require('util');
    const pipelineAsync = promisify(pipeline);

    async function processData() {
        try {
            await pipelineAsync(
                fs.createReadStream('input.txt'),
                new Transform({
                    transform(chunk, encoding, callback) {
                        // 数据处理
                        try {
                            const result = processChunk(chunk);
                            callback(null, result);
                        } catch (error) {
                            callback(error); // 正确传递错误
                        }
                    }
                }),
                fs.createWriteStream('output.txt')
            );
            console.log('管道处理成功完成');
        } catch (error) {
            console.error('管道处理失败:', error);
            // 清理资源
            await cleanupResources();
        }
    }
}

// 背压处理
class BackpressureAwareStream extends Transform {
    constructor(options) {
        super({ 
            highWaterMark: 16384, // 16KB缓冲区
            ...options 
        });
    }

    _transform(chunk, encoding, callback) {
        // 检查背压
        if (!this.writable) {
            callback(new Error('流已结束'));
            return;
        }

        // 模拟异步处理
        this.processAsync(chunk)
            .then(result => {
                if (this.writable) {
                    this.push(result);
                }
                callback();
            })
            .catch(callback);
    }

    async processAsync(chunk) {
        // 异步处理逻辑
        return chunk;
    }
}
```

这些高级应用展示了Stream和Child Process模块在构建高性能、可扩展Node.js应用中的强大能力。正确使用这些工具可以显著提升应用的吞吐量、稳定性和资源利用率。