å…³äºNode.jsä¸­ä½¿ç”¨`exec`åˆ›å»ºçš„å­è¿›ç¨‹æ˜¯å¦ä¼šè‡ªåŠ¨é”€æ¯ï¼Œç®€å•æ¥è¯´ï¼š**å½“å­è¿›ç¨‹è‡ªå·±æ­£å¸¸æ‰§è¡Œå®Œæ¯•æ—¶ï¼Œå®ƒä¼šè‡ªåŠ¨é€€å‡ºï¼›ä½†å¦‚æœä½ éœ€è¦åœ¨ä¸­é€”ä¸»åŠ¨ç»ˆæ­¢å®ƒï¼Œæˆ–è€…ä¸»è¿›ç¨‹å¼‚å¸¸é€€å‡ºï¼Œåˆ™éœ€è¦ä½ æ‰‹åŠ¨å¤„ç†ã€‚**

### ğŸ”„ å­è¿›ç¨‹çš„ç”Ÿå‘½å‘¨æœŸç®¡ç†

ä¸ºäº†è®©ä½ æ›´æ¸…æ™°åœ°äº†è§£ä¸åŒæƒ…å†µï¼Œå¯ä»¥å‚è€ƒä¸‹è¡¨ï¼š

| åœºæ™¯ | å­è¿›ç¨‹æ˜¯å¦ä¼šè‡ªåŠ¨é€€å‡ºï¼Ÿ | è¯´æ˜ä¸å»ºè®® |
| :--- | :--- | :--- |
| **å­è¿›ç¨‹æ­£å¸¸å®Œæˆ** | âœ… **æ˜¯** | ä»»åŠ¡å®Œæˆåï¼Œå­è¿›ç¨‹è‡ªåŠ¨é€€å‡ºï¼Œå›è°ƒå‡½æ•°è¢«è°ƒç”¨ã€‚ |
| **ä¸­é€”ä¸»åŠ¨ç»ˆæ­¢** | âŒ **å¦** | éœ€è¦ä½ æ‰‹åŠ¨è°ƒç”¨ `child.kill()` æˆ– `child.kill('SIGTERM')` ã€‚ä¹Ÿå¯ä»¥å‘é€ `SIGKILL` ç­‰ä¿¡å·ã€‚ |
| **ä¸»è¿›ç¨‹å…ˆé€€å‡º** | âŒ **å¦** | å­è¿›ç¨‹å¯èƒ½æˆä¸º"å­¤å„¿è¿›ç¨‹"ç»§ç»­è¿è¡Œã€‚éœ€è¦åœ¨ä¸»è¿›ç¨‹çš„ `exit` äº‹ä»¶ä¸­æ‰‹åŠ¨æ¸…ç†ã€‚ |
| **è¾“å‡ºè¶…è¿‡é»˜è®¤é™åˆ¶** | âœ… **æ˜¯** | é»˜è®¤ `maxBuffer` ä¸º 200KBã€‚è¶…è¿‡æ­¤é™åˆ¶ï¼Œå­è¿›ç¨‹ä¼šè¢«è‡ªåŠ¨ç»ˆæ­¢ã€‚ |

### ğŸ’¡ å®ç”¨ä»£ç ç¤ºä¾‹

ä»¥ä¸‹æ˜¯ä¸€äº›å…³é”®æ“ä½œçš„ä»£ç ç¤ºä¾‹ï¼Œå¸®åŠ©ä½ æ›´å¥½åœ°ç†è§£ï¼š

#### 1. åˆ›å»ºå¹¶è®¾ç½®è¶…æ—¶ç»ˆæ­¢
```javascript
const { exec } = require('child_process');

const child = exec('your-command-here', (error, stdout, stderr) => {
  if (error) {
    console.error(`æ‰§è¡Œå‡ºé”™: ${error}`);
    return;
  }
  console.log(`è¾“å‡º: ${stdout}`);
});

// è®¾ç½®ä¸€ä¸ª10ç§’çš„è¶…æ—¶ï¼Œå¦‚æœå­è¿›ç¨‹æœªå®Œæˆåˆ™ç»ˆæ­¢å®ƒ
setTimeout(() => {
  // æ£€æŸ¥è¿›ç¨‹æ˜¯å¦è¿˜åœ¨è¿è¡Œ
  if (!child.killed) { 
    child.kill();
    console.log('å­è¿›ç¨‹å·²è¶…æ—¶ç»ˆæ­¢');
  }
}, 10000);
```
**è¯´æ˜**ï¼šè¿™ç§æ–¹å¼é€‚ç”¨äºæ§åˆ¶å‘½ä»¤çš„æœ€å¤§æ‰§è¡Œæ—¶é—´ã€‚

#### 2. ä¸»è¿›ç¨‹é€€å‡ºæ—¶æ¸…ç†å­è¿›ç¨‹
```javascript
const { spawn } = require('child_process');
const child = spawn('node', ['child.js']);

// ç›‘å¬ä¸»è¿›ç¨‹çš„é€€å‡ºäº‹ä»¶ï¼Œå¹¶æ¸…ç†å­è¿›ç¨‹
process.on('exit', () => {
  child.kill();
});
```
**è¯´æ˜**ï¼šç¡®ä¿åœ¨ä¸»è¿›ç¨‹æ„å¤–é€€å‡ºæ—¶ï¼Œä¸ä¼šç•™ä¸‹æ®‹ç•™çš„å­è¿›ç¨‹ã€‚è¿™é‡Œä½¿ç”¨`spawn`ä½œä¸ºç¤ºä¾‹ï¼Œ`exec`åˆ›å»ºçš„å­è¿›ç¨‹åŒæ ·é€‚ç”¨ã€‚

#### 3. å¤„ç†è¾“å‡ºç¼“å†²åŒºé™åˆ¶
```javascript
const { exec } = require('child_process');

const child = exec('your-command-here', { 
  maxBuffer: 1024 * 1024 // å°†ç¼“å†²åŒºå¤§å°è®¾ç½®ä¸º1MBï¼Œæ ¹æ®éœ€è¦è°ƒæ•´
}, (error, stdout, stderr) => {
  // å›è°ƒå‡½æ•°é€»è¾‘
});
```
**è¯´æ˜**ï¼šå¦‚æœä½ çš„å‘½ä»¤ä¼šäº§ç”Ÿå¤§é‡è¾“å‡ºï¼Œè®°å¾—è°ƒæ•´`maxBuffer`é€‰é¡¹ä»¥é¿å…æ„å¤–ç»ˆæ­¢ã€‚

### âš ï¸ å…³äº`exec`çš„è¿›é˜¶æé†’

- **å®‰å…¨è€ƒè™‘**ï¼š`exec`ä¼š**å¯åŠ¨ä¸€ä¸ªShell**æ¥è§£æå‘½ä»¤ï¼Œå¦‚æœå‘½ä»¤å­—ç¬¦ä¸²ä¸­åŒ…å«ç”¨æˆ·è¾“å…¥ï¼Œä¼šæœ‰**å‘½ä»¤æ³¨å…¥çš„é£é™©**ã€‚åœ¨éœ€è¦å¤„ç†ç”¨æˆ·è¾“å…¥æˆ–å¯¹æ€§èƒ½è¦æ±‚è¾ƒé«˜çš„åœºæ™¯ä¸‹ï¼Œæ›´æ¨èä½¿ç”¨é»˜è®¤ä¸å¯åŠ¨Shellçš„ `spawn` æˆ– `execFile`ã€‚

å¸Œæœ›è¿™äº›ä¿¡æ¯èƒ½å¸®åŠ©ä½ æ›´å¥½åœ°ç®¡ç†Node.jsä¸­çš„å­è¿›ç¨‹ã€‚å¦‚æœä½ å¯¹ç‰¹å®šåœºæ™¯ï¼ˆä¾‹å¦‚å¦‚ä½•é˜²æ­¢å‘½ä»¤æ³¨å…¥ï¼‰æœ‰è¿›ä¸€æ­¥çš„ç–‘é—®ï¼Œæˆ‘å¾ˆä¹æ„æä¾›æ›´å¤šè¯´æ˜ã€‚

# Node.js Stream ä¸ Child Process æ·±åº¦è¯¦è§£

## ğŸŒŠ **Stream æ¨¡å— - å…¨é¢æ·±å…¥**

### æ ¸å¿ƒæ¦‚å¿µä¸æµç±»å‹

#### å››ç§åŸºæœ¬æµç±»å‹
```javascript
const { Readable, Writable, Duplex, Transform } = require('stream');

// 1. å¯è¯»æµ (Readable) - æ•°æ®æº
class MyReadable extends Readable {
    constructor(options) {
        super(options);
        this.data = ['æ•°æ®å—1', 'æ•°æ®å—2', 'æ•°æ®å—3'];
        this.index = 0;
    }

    _read(size) {
        if (this.index < this.data.length) {
            this.push(this.data[this.index++]);
        } else {
            this.push(null); // ç»“æŸæµ
        }
    }
}

// 2. å¯å†™æµ (Writable) - æ•°æ®ç›®çš„åœ°
class MyWritable extends Writable {
    _write(chunk, encoding, callback) {
        console.log(`å†™å…¥æ•°æ®: ${chunk.toString()}`);
        callback(); // å¿…é¡»è°ƒç”¨ï¼Œè¡¨ç¤ºå†™å…¥å®Œæˆ
    }
}

// 3. åŒå·¥æµ (Duplex) - å¯è¯»å¯å†™
class MyDuplex extends Duplex {
    constructor(options) {
        super(options);
        this.data = [];
    }

    _write(chunk, encoding, callback) {
        this.data.push(chunk);
        callback();
    }

    _read(size) {
        if (this.data.length > 0) {
            this.push(this.data.shift());
        } else {
            this.push(null);
        }
    }
}

// 4. è½¬æ¢æµ (Transform) - æ•°æ®å¤„ç†è½¬æ¢
class MyTransform extends Transform {
    _transform(chunk, encoding, callback) {
        const transformed = chunk.toString().toUpperCase();
        this.push(transformed);
        callback();
    }
}
```

### é«˜çº§æµåº”ç”¨åœºæ™¯

#### 1. å¤§æ•°æ®å®æ—¶åˆ†æç®¡é“
```javascript
const { pipeline, Transform } = require('stream');
const fs = require('fs');

// å®æ—¶æ—¥å¿—åˆ†æç³»ç»Ÿ
class LogParser extends Transform {
    constructor() {
        super({ objectMode: true }); // å¯¹è±¡æ¨¡å¼ï¼Œå¤„ç†JSå¯¹è±¡è€ŒéBuffer
    }

    _transform(chunk, encoding, callback) {
        try {
            const logEntry = chunk.toString();
            const parsed = this.parseLogEntry(logEntry);
            if (parsed) this.push(parsed);
            callback();
        } catch (error) {
            callback(error);
        }
    }

    parseLogEntry(entry) {
        const regex = /\[(.*?)\] (\w+): (.*)/;
        const match = entry.match(regex);
        if (match) {
            return {
                timestamp: new Date(match[1]),
                level: match[2],
                message: match[3],
                processedAt: new Date()
            };
        }
        return null;
    }
}

class LogAnalyzer extends Transform {
    constructor() {
        super({ objectMode: true });
        this.stats = {
            errors: 0,
            warnings: 0,
            infos: 0
        };
    }

    _transform(logObj, encoding, callback) {
        // å®æ—¶ç»Ÿè®¡
        if (logObj.level === 'ERROR') this.stats.errors++;
        if (logObj.level === 'WARN') this.stats.warnings++;
        if (logObj.level === 'INFO') this.stats.infos++;

        // æ·»åŠ åˆ†æç»“æœ
        logObj.analysis = {
            isError: logObj.level === 'ERROR',
            isRecent: Date.now() - logObj.timestamp < 5 * 60 * 1000,
            stats: { ...this.stats }
        };

        this.push(logObj);
        callback();
    }
}

// æ„å»ºå®Œæ•´çš„æ•°æ®å¤„ç†ç®¡é“
pipeline(
    fs.createReadStream('./app.log', { highWaterMark: 64 * 1024 }), // 64KBç¼“å†²åŒº
    new LogParser(),
    new LogAnalyzer(),
    new Transform({
        objectMode: true,
        transform(logObj, encoding, callback) {
            // è¾“å‡ºåˆ°æ§åˆ¶å°å’Œæ–‡ä»¶
            console.log('åˆ†æç»“æœ:', logObj.analysis);
            this.push(JSON.stringify(logObj) + '\n');
            callback();
        }
    }),
    fs.createWriteStream('./analyzed-logs.jsonl'),
    (err) => {
        if (err) {
            console.error('ç®¡é“å¤„ç†å¤±è´¥:', err);
        } else {
            console.log('æ—¥å¿—åˆ†æå®Œæˆ');
        }
    }
);
```

#### 2. å®æ—¶è§†é¢‘æµå¤„ç†
```javascript
const { Transform, PassThrough } = require('stream');
const crypto = require('crypto');

// è§†é¢‘æµåŠ å¯†ä¼ è¾“ç³»ç»Ÿ
class VideoEncryptor extends Transform {
    constructor(password) {
        super();
        this.algorithm = 'aes-256-ctr';
        this.key = crypto.scryptSync(password, 'salt', 32);
        this.iv = crypto.randomBytes(16);
        this.cipher = crypto.createCipheriv(this.algorithm, this.key, this.iv);
        
        // é¦–å…ˆå‘é€IV
        this.push(this.iv);
    }

    _transform(chunk, encoding, callback) {
        try {
            const encrypted = this.cipher.update(chunk);
            this.push(encrypted);
            callback();
        } catch (error) {
            callback(error);
        }
    }

    _flush(callback) {
        try {
            const finalBlock = this.cipher.final();
            this.push(finalBlock);
            callback();
        } catch (error) {
            callback(error);
        }
    }
}

class VideoStreamProcessor extends Duplex {
    constructor(options) {
        super(options);
        this.buffers = [];
        this.processing = false;
    }

    _write(chunk, encoding, callback) {
        this.buffers.push(chunk);
        if (!this.processing) {
            this.processBuffers();
        }
        callback();
    }

    _read(size) {
        // æ•°æ®é€šè¿‡pushæ–¹æ³•æä¾›
    }

    async processBuffers() {
        this.processing = true;
        
        while (this.buffers.length > 0) {
            const chunk = this.buffers.shift();
            
            // æ¨¡æ‹Ÿè§†é¢‘å¤„ç†ï¼šæ·»åŠ æ°´å°ã€è°ƒæ•´è´¨é‡ç­‰
            const processed = await this.processVideoChunk(chunk);
            
            if (!this.push(processed)) {
                // å¦‚æœæ¶ˆè´¹è€…è·Ÿä¸ä¸Šï¼Œæš‚åœå¤„ç†
                break;
            }
        }
        
        this.processing = false;
    }

    async processVideoChunk(chunk) {
        // æ¨¡æ‹Ÿå¼‚æ­¥è§†é¢‘å¤„ç†
        return new Promise(resolve => {
            setTimeout(() => {
                // åœ¨å®é™…åº”ç”¨ä¸­ï¼Œè¿™é‡Œå¯èƒ½æ˜¯FFmpegå¤„ç†ã€æ°´å°æ·»åŠ ç­‰
                const processed = Buffer.concat([
                    Buffer.from(`[FRAME:${Date.now()}]`),
                    chunk
                ]);
                resolve(processed);
            }, 10);
        });
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šè§†é¢‘æµåŠ å¯†ä¼ è¾“
function createSecureVideoStream(inputPath, password) {
    const videoStream = fs.createReadStream(inputPath);
    const encryptor = new VideoEncryptor(password);
    const processor = new VideoStreamProcessor();
    
    return videoStream.pipe(processor).pipe(encryptor);
}
```

#### 3. æ•°æ®åº“æµå¼å¯¼å…¥å¯¼å‡º
```javascript
const { Transform } = require('stream');
const { MongoClient } = require('mongodb');

class MongoExporter extends Readable {
    constructor(collection, query = {}, batchSize = 1000) {
        super({ objectMode: true });
        this.collection = collection;
        this.query = query;
        this.batchSize = batchSize;
        this.cursor = null;
        this.isReading = false;
    }

    async _read(size) {
        if (this.isReading) return;
        
        this.isReading = true;
        
        if (!this.cursor) {
            this.cursor = this.collection.find(this.query).batchSize(this.batchSize);
        }
        
        try {
            let count = 0;
            while (await this.cursor.hasNext() && count < size) {
                const doc = await this.cursor.next();
                if (!this.push(doc)) {
                    break;
                }
                count++;
            }
            
            if (!await this.cursor.hasNext()) {
                this.push(null); // ç»“æŸæµ
                await this.cursor.close();
            }
        } catch (error) {
            this.destroy(error);
        }
        
        this.isReading = false;
    }
}

class DataTransformer extends Transform {
    constructor(transformFn) {
        super({ objectMode: true });
        this.transformFn = transformFn;
    }

    async _transform(chunk, encoding, callback) {
        try {
            const transformed = await this.transformFn(chunk);
            if (transformed) {
                this.push(transformed);
            }
            callback();
        } catch (error) {
            callback(error);
        }
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šå¤§æ•°æ®å¯¼å‡ºå’Œè½¬æ¢
async function exportAndTransformData() {
    const client = await MongoClient.connect('mongodb://localhost:27017');
    const db = client.db('mydb');
    const collection = db.collection('large_dataset');
    
    const exporter = new MongoExporter(collection, { status: 'active' });
    const transformer = new DataTransformer(async (doc) => {
        // æ•°æ®æ¸…æ´—å’Œè½¬æ¢
        return {
            id: doc._id.toString(),
            name: doc.name.trim(),
            email: doc.email.toLowerCase(),
            createdAt: new Date(),
            metadata: {
                original: doc,
                processedBy: 'stream-pipeline'
            }
        };
    });
    
    return exporter.pipe(transformer);
}
```

## ğŸ‘¶ **Child Process æ¨¡å— - å…¨é¢æ·±å…¥**

### è¿›ç¨‹åˆ›å»ºæ–¹å¼å¯¹æ¯”

| æ–¹æ³• | ä½¿ç”¨åœºæ™¯ | ç‰¹ç‚¹ | è¿”å›å€¼ |
|------|----------|------|---------|
| `exec` | æ‰§è¡ŒShellå‘½ä»¤ | ç¼“å†²è¾“å‡ºï¼Œé€‚åˆå°é‡æ•°æ® | Buffer |
| `execFile` | æ‰§è¡Œå¯æ‰§è¡Œæ–‡ä»¶ | ä¸å¯åŠ¨Shellï¼Œæ›´å®‰å…¨ | Buffer |
| `spawn` | é•¿æ—¶é—´è¿è¡Œè¿›ç¨‹ | æµå¼I/Oï¼Œé€‚åˆå¤§é‡æ•°æ® | Stream |
| `fork` | Node.jsæ¨¡å— | ç‰¹æ®Šspawnï¼ŒIPCé€šä¿¡ | å­è¿›ç¨‹å¯¹è±¡ |

### é«˜çº§è¿›ç¨‹ç®¡ç†

#### 1. è¿›ç¨‹æ± ç®¡ç†ç³»ç»Ÿ
```javascript
const { fork } = require('child_process');
const path = require('path');
const EventEmitter = require('events');

class ProcessPool extends EventEmitter {
    constructor(scriptPath, poolSize = 4) {
        super();
        this.scriptPath = scriptPath;
        this.poolSize = poolSize;
        this.availableWorkers = [];
        this.busyWorkers = new Map();
        this.taskQueue = [];
        this.workerIdCounter = 0;

        this.initializeWorkers();
    }

    initializeWorkers() {
        for (let i = 0; i < this.poolSize; i++) {
            this.createWorker();
        }
    }

    createWorker() {
        const worker = fork(this.scriptPath, [], {
            stdio: ['pipe', 'pipe', 'pipe', 'ipc'],
            execArgv: ['--max-old-space-size=4096'] // 4GBå†…å­˜é™åˆ¶
        });

        const workerId = this.workerIdCounter++;
        
        worker.workerId = workerId;
        worker.available = true;

        worker.on('message', (result) => {
            this.handleWorkerResult(worker, result);
        });

        worker.on('error', (error) => {
            console.error(`Worker ${workerId} é”™è¯¯:`, error);
            this.restartWorker(worker);
        });

        worker.on('exit', (code, signal) => {
            console.log(`Worker ${workerId} é€€å‡ºï¼Œä»£ç : ${code}, ä¿¡å·: ${signal}`);
            if (code !== 0) {
                this.restartWorker(worker);
            }
        });

        // ç›‘æ§å†…å­˜ä½¿ç”¨
        setInterval(() => {
            if (worker.connected) {
                worker.send({ type: 'STATUS_REQUEST' });
            }
        }, 30000);

        this.availableWorkers.push(worker);
        this.emit('workerCreated', workerId);
    }

    executeTask(taskData, timeout = 30000) {
        return new Promise((resolve, reject) => {
            const task = {
                data: taskData,
                resolve,
                reject,
                timeoutId: null
            };

            // è®¾ç½®è¶…æ—¶
            if (timeout > 0) {
                task.timeoutId = setTimeout(() => {
                    const index = this.taskQueue.indexOf(task);
                    if (index > -1) {
                        this.taskQueue.splice(index, 1);
                    }
                    reject(new Error(`ä»»åŠ¡æ‰§è¡Œè¶…æ—¶ (${timeout}ms)`));
                }, timeout);
            }

            this.taskQueue.push(task);
            this.processNextTask();
        });
    }

    processNextTask() {
        if (this.taskQueue.length === 0 || this.availableWorkers.length === 0) {
            return;
        }

        const task = this.taskQueue.shift();
        const worker = this.availableWorkers.pop();

        if (task.timeoutId) {
            clearTimeout(task.timeoutId);
        }

        worker.available = false;
        this.busyWorkers.set(worker.workerId, { worker, task });

        try {
            worker.send({
                type: 'EXECUTE_TASK',
                data: task.data,
                taskId: Date.now() + Math.random()
            });

            this.emit('taskStarted', worker.workerId, task.data);
        } catch (error) {
            task.reject(error);
            this.releaseWorker(worker);
        }
    }

    handleWorkerResult(worker, result) {
        const busyWorker = this.busyWorkers.get(worker.workerId);
        if (!busyWorker) return;

        const { task } = busyWorker;

        if (result.type === 'TASK_RESULT') {
            task.resolve(result.data);
            this.emit('taskCompleted', worker.workerId, result.data);
        } else if (result.type === 'TASK_ERROR') {
            task.reject(new Error(result.error));
            this.emit('taskFailed', worker.workerId, result.error);
        } else if (result.type === 'STATUS_RESPONSE') {
            this.emit('workerStatus', worker.workerId, result.data);
            return; // çŠ¶æ€å“åº”ä¸é‡Šæ”¾worker
        }

        this.busyWorkers.delete(worker.workerId);
        this.releaseWorker(worker);
    }

    releaseWorker(worker) {
        worker.available = true;
        this.availableWorkers.push(worker);
        this.processNextTask();
    }

    restartWorker(worker) {
        const index = this.availableWorkers.indexOf(worker);
        if (index > -1) {
            this.availableWorkers.splice(index, 1);
        }
        this.busyWorkers.delete(worker.workerId);
        
        if (worker.connected) {
            worker.kill('SIGTERM');
        }
        
        setTimeout(() => this.createWorker(), 1000);
    }

    async drain() {
        // ç­‰å¾…æ‰€æœ‰ä»»åŠ¡å®Œæˆ
        while (this.busyWorkers.size > 0 || this.taskQueue.length > 0) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }

        // ç»ˆæ­¢æ‰€æœ‰worker
        this.availableWorkers.forEach(worker => {
            if (worker.connected) {
                worker.kill('SIGTERM');
            }
        });
        
        this.availableWorkers = [];
        this.busyWorkers.clear();
    }
}

// ä½¿ç”¨ç¤ºä¾‹
const pool = new ProcessPool('./worker-script.js', 4);

// ç›‘æ§äº‹ä»¶
pool.on('workerCreated', (workerId) => {
    console.log(`Worker ${workerId} å·²åˆ›å»º`);
});

pool.on('taskStarted', (workerId, taskData) => {
    console.log(`Worker ${workerId} å¼€å§‹å¤„ç†ä»»åŠ¡`);
});

// æ‰§è¡Œä»»åŠ¡
async function processMultipleTasks() {
    const tasks = [
        { type: 'image_processing', file: 'image1.jpg' },
        { type: 'data_analysis', dataset: 'large.csv' },
        { type: 'video_encoding', video: 'video.mp4' }
    ];

    const results = await Promise.allSettled(
        tasks.map(task => pool.executeTask(task, 60000))
    );

    return results;
}
```

#### 2. å®æ—¶è¿›ç¨‹ç›‘æ§å’Œè‡ªåŠ¨æ¢å¤
```javascript
const { spawn } = require('child_process');
const os = require('os');

class MonitoredProcess {
    constructor(command, args = [], options = {}) {
        this.command = command;
        this.args = args;
        this.options = { 
            stdio: ['pipe', 'pipe', 'pipe'],
            ...options 
        };
        
        this.process = null;
        this.restartCount = 0;
        this.maxRestarts = 5;
        this.restartDelay = 1000;
        this.metrics = {
            startTime: null,
            cpuUsage: 0,
            memoryUsage: 0,
            outputSize: 0
        };
        
        this.start();
    }

    start() {
        this.process = spawn(this.command, this.args, this.options);
        this.metrics.startTime = new Date();
        
        console.log(`è¿›ç¨‹å¯åŠ¨: ${this.command} ${this.args.join(' ')}`);

        // æ ‡å‡†è¾“å‡ºå¤„ç†
        this.process.stdout.on('data', (data) => {
            this.metrics.outputSize += data.length;
            console.log(`[STDOUT] ${data.toString().trim()}`);
        });

        // é”™è¯¯è¾“å‡ºå¤„ç†
        this.process.stderr.on('data', (data) => {
            console.error(`[STDERR] ${data.toString().trim()}`);
        });

        // è¿›ç¨‹é€€å‡ºå¤„ç†
        this.process.on('exit', (code, signal) => {
            console.log(`è¿›ç¨‹é€€å‡ºï¼Œä»£ç : ${code}, ä¿¡å·: ${signal}`);
            this.handleExit(code, signal);
        });

        this.process.on('error', (error) => {
            console.error(`è¿›ç¨‹é”™è¯¯: ${error.message}`);
            this.handleExit(1, null);
        });

        // å¼€å§‹ç›‘æ§
        this.startMonitoring();
    }

    handleExit(code, signal) {
        if (code === 0 || signal === 'SIGTERM') {
            console.log('è¿›ç¨‹æ­£å¸¸é€€å‡º');
            return;
        }

        if (this.restartCount < this.maxRestarts) {
            this.restartCount++;
            console.log(`å‡†å¤‡é‡å¯è¿›ç¨‹ (${this.restartCount}/${this.maxRestarts})...`);
            
            setTimeout(() => {
                this.start();
            }, this.restartDelay * this.restartCount); // é€’å¢å»¶è¿Ÿ
        } else {
            console.error('è¾¾åˆ°æœ€å¤§é‡å¯æ¬¡æ•°ï¼Œåœæ­¢é‡å¯');
            this.emit('failed');
        }
    }

    startMonitoring() {
        this.monitorInterval = setInterval(() => {
            if (this.process && this.process.pid) {
                this.collectMetrics();
            }
        }, 5000);
    }

    collectMetrics() {
        // æ”¶é›†è¿›ç¨‹æŒ‡æ ‡
        try {
            const memoryUsage = process.memoryUsage();
            this.metrics.memoryUsage = memoryUsage.rss;
            this.metrics.cpuUsage = process.cpuUsage();
            
            // æ£€æŸ¥èµ„æºä½¿ç”¨æƒ…å†µ
            if (memoryUsage.rss > 500 * 1024 * 1024) { // 500MB
                console.warn('è¿›ç¨‹å†…å­˜ä½¿ç”¨è¿‡é«˜:', memoryUsage.rss);
            }
        } catch (error) {
            console.error('æ”¶é›†æŒ‡æ ‡å¤±è´¥:', error);
        }
    }

    sendCommand(command) {
        if (this.process && this.process.stdin.writable) {
            this.process.stdin.write(command + '\n');
            return true;
        }
        return false;
    }

    gracefulShutdown() {
        clearInterval(this.monitorInterval);
        
        if (this.process) {
            this.process.kill('SIGTERM');
            
            // å¼ºåˆ¶å…³é—­è¶…æ—¶
            setTimeout(() => {
                if (this.process) {
                    this.process.kill('SIGKILL');
                }
            }, 10000);
        }
    }

    getStatus() {
        return {
            pid: this.process ? this.process.pid : null,
            running: this.process !== null,
            restartCount: this.restartCount,
            metrics: this.metrics,
            uptime: this.metrics.startTime ? 
                Date.now() - this.metrics.startTime.getTime() : 0
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹ï¼šç›‘æ§å…³é”®æœåŠ¡
const nginxProcess = new MonitoredProcess('nginx', ['-g', 'daemon off;'], {
    cwd: '/etc/nginx',
    env: { ...process.env, NGINX_ENV: 'production' }
});

// åˆ›å»ºç›‘æ§æ¥å£
const http = require('http');
const server = http.createServer((req, res) => {
    if (req.url === '/status') {
        res.writeHead(200, { 'Content-Type': 'application/json' });
        res.end(JSON.stringify(nginxProcess.getStatus()));
    } else if (req.url === '/restart' && req.method === 'POST') {
        nginxProcess.gracefulShutdown();
        res.end('é‡å¯æŒ‡ä»¤å·²å‘é€');
    }
});

server.listen(8080);
```

#### 3. åˆ†å¸ƒå¼ä»»åŠ¡å¤„ç†ç³»ç»Ÿ
```javascript
const { Worker } = require('worker_threads');
const cluster = require('cluster');
const numCPUs = require('os').cpus().length;

class DistributedTaskSystem {
    constructor() {
        this.workers = new Map();
        this.taskQueue = [];
        this.completedTasks = new Map();
        this.isMaster = cluster.isMaster;
        
        if (this.isMaster) {
            this.setupMaster();
        } else {
            this.setupWorker();
        }
    }

    setupMaster() {
        console.log(`ä¸»è¿›ç¨‹ ${process.pid} å¯åŠ¨`);

        // åˆ›å»ºå·¥ä½œè¿›ç¨‹
        for (let i = 0; i < numCPUs; i++) {
            const worker = cluster.fork();
            
            worker.on('message', (message) => {
                this.handleWorkerMessage(worker, message);
            });

            this.workers.set(worker.id, {
                process: worker,
                busy: false,
                currentTask: null
            });
        }

        cluster.on('exit', (worker, code, signal) => {
            console.log(`å·¥ä½œè¿›ç¨‹ ${worker.process.pid} é€€å‡º`);
            this.workers.delete(worker.id);
            
            // è‡ªåŠ¨é‡å¯
            setTimeout(() => {
                const newWorker = cluster.fork();
                this.workers.set(newWorker.id, {
                    process: newWorker,
                    busy: false,
                    currentTask: null
                });
            }, 1000);
        });

        // å¼€å§‹å¤„ç†ä»»åŠ¡
        this.processTaskQueue();
    }

    setupWorker() {
        // å·¥ä½œè¿›ç¨‹å‡†å¤‡æ¥æ”¶ä»»åŠ¡
        process.on('message', async (message) => {
            if (message.type === 'EXECUTE_TASK') {
                try {
                    const result = await this.executeTask(message.task);
                    process.send({
                        type: 'TASK_COMPLETED',
                        taskId: message.taskId,
                        result: result
                    });
                } catch (error) {
                    process.send({
                        type: 'TASK_FAILED',
                        taskId: message.taskId,
                        error: error.message
                    });
                }
            }
        });
    }

    async executeTask(task) {
        // æ ¹æ®ä»»åŠ¡ç±»å‹æ‰§è¡Œä¸åŒçš„å¤„ç†é€»è¾‘
        switch (task.type) {
            case 'DATA_PROCESSING':
                return await this.processData(task.data);
            case 'IMAGE_PROCESSING':
                return await this.processImage(task.data);
            case 'ML_INFERENCE':
                return await this.runMLInference(task.data);
            default:
                throw new Error(`æœªçŸ¥ä»»åŠ¡ç±»å‹: ${task.type}`);
        }
    }

    async processData(data) {
        // æ¨¡æ‹Ÿæ•°æ®å¤„ç†
        return new Promise(resolve => {
            setTimeout(() => {
                resolve({
                    processed: true,
                    records: data.length,
                    timestamp: new Date()
                });
            }, 1000);
        });
    }

    submitTask(task, priority = 0) {
        const taskId = this.generateTaskId();
        const taskItem = {
            id: taskId,
            task: task,
            priority: priority,
            submittedAt: new Date(),
            status: 'pending'
        };

        // æ ¹æ®ä¼˜å…ˆçº§æ’å…¥é˜Ÿåˆ—
        const index = this.taskQueue.findIndex(t => t.priority < priority);
        if (index === -1) {
            this.taskQueue.push(taskItem);
        } else {
            this.taskQueue.splice(index, 0, taskItem);
        }

        return taskId;
    }

    processTaskQueue() {
        setInterval(() => {
            if (this.taskQueue.length === 0) return;

            // æŸ¥æ‰¾ç©ºé—²worker
            const availableWorker = Array.from(this.workers.values())
                .find(w => !w.busy);

            if (availableWorker) {
                const task = this.taskQueue.shift();
                availableWorker.busy = true;
                availableWorker.currentTask = task;

                availableWorker.process.send({
                    type: 'EXECUTE_TASK',
                    taskId: task.id,
                    task: task.task
                });

                task.status = 'processing';
                console.log(`ä»»åŠ¡ ${task.id} åˆ†é…ç»™å·¥ä½œè¿›ç¨‹ ${availableWorker.process.id}`);
            }
        }, 100);
    }

    handleWorkerMessage(worker, message) {
        const workerInfo = this.workers.get(worker.id);
        
        switch (message.type) {
            case 'TASK_COMPLETED':
                workerInfo.busy = false;
                workerInfo.currentTask.status = 'completed';
                
                this.completedTasks.set(message.taskId, {
                    result: message.result,
                    completedAt: new Date()
                });
                
                console.log(`ä»»åŠ¡ ${message.taskId} å®Œæˆ`);
                break;

            case 'TASK_FAILED':
                workerInfo.busy = false;
                workerInfo.currentTask.status = 'failed';
                
                console.error(`ä»»åŠ¡ ${message.taskId} å¤±è´¥:`, message.error);
                break;
        }
    }

    generateTaskId() {
        return `task_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    }

    getSystemStatus() {
        return {
            totalWorkers: this.workers.size,
            busyWorkers: Array.from(this.workers.values()).filter(w => w.busy).length,
            pendingTasks: this.taskQueue.length,
            completedTasks: this.completedTasks.size,
            workers: Array.from(this.workers.values()).map(w => ({
                id: w.process.id,
                busy: w.busy,
                currentTask: w.currentTask ? w.currentTask.id : null
            }))
        };
    }
}

// ä½¿ç”¨ç¤ºä¾‹
if (cluster.isMaster) {
    const taskSystem = new DistributedTaskSystem();
    
    // æäº¤å¤šä¸ªä»»åŠ¡
    for (let i = 0; i < 100; i++) {
        taskSystem.submitTask({
            type: 'DATA_PROCESSING',
            data: Array(1000).fill(i).map((val, idx) => ({ id: idx, value: val }))
        }, Math.floor(Math.random() * 3));
    }
    
    // ç›‘æ§ç³»ç»ŸçŠ¶æ€
    setInterval(() => {
        console.log('ç³»ç»ŸçŠ¶æ€:', taskSystem.getSystemStatus());
    }, 5000);
}
```

### æ€§èƒ½ä¼˜åŒ–å’Œæœ€ä½³å®è·µ

#### 1. æµå¼å¤„ç†çš„æœ€ä½³å®è·µ
```javascript
// é”™è¯¯å¤„ç†
function createRobustStreamPipeline() {
    const { pipeline } = require('stream');
    const { promisify } = require('util');
    const pipelineAsync = promisify(pipeline);

    async function processData() {
        try {
            await pipelineAsync(
                fs.createReadStream('input.txt'),
                new Transform({
                    transform(chunk, encoding, callback) {
                        // æ•°æ®å¤„ç†
                        try {
                            const result = processChunk(chunk);
                            callback(null, result);
                        } catch (error) {
                            callback(error); // æ­£ç¡®ä¼ é€’é”™è¯¯
                        }
                    }
                }),
                fs.createWriteStream('output.txt')
            );
            console.log('ç®¡é“å¤„ç†æˆåŠŸå®Œæˆ');
        } catch (error) {
            console.error('ç®¡é“å¤„ç†å¤±è´¥:', error);
            // æ¸…ç†èµ„æº
            await cleanupResources();
        }
    }
}

// èƒŒå‹å¤„ç†
class BackpressureAwareStream extends Transform {
    constructor(options) {
        super({ 
            highWaterMark: 16384, // 16KBç¼“å†²åŒº
            ...options 
        });
    }

    _transform(chunk, encoding, callback) {
        // æ£€æŸ¥èƒŒå‹
        if (!this.writable) {
            callback(new Error('æµå·²ç»“æŸ'));
            return;
        }

        // æ¨¡æ‹Ÿå¼‚æ­¥å¤„ç†
        this.processAsync(chunk)
            .then(result => {
                if (this.writable) {
                    this.push(result);
                }
                callback();
            })
            .catch(callback);
    }

    async processAsync(chunk) {
        // å¼‚æ­¥å¤„ç†é€»è¾‘
        return chunk;
    }
}
```

è¿™äº›é«˜çº§åº”ç”¨å±•ç¤ºäº†Streamå’ŒChild Processæ¨¡å—åœ¨æ„å»ºé«˜æ€§èƒ½ã€å¯æ‰©å±•Node.jsåº”ç”¨ä¸­çš„å¼ºå¤§èƒ½åŠ›ã€‚æ­£ç¡®ä½¿ç”¨è¿™äº›å·¥å…·å¯ä»¥æ˜¾è‘—æå‡åº”ç”¨çš„ååé‡ã€ç¨³å®šæ€§å’Œèµ„æºåˆ©ç”¨ç‡ã€‚