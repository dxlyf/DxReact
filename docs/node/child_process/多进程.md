# Node.js 核心模块应用场景与功能详解

## 📁 **fs 模块 - 文件系统操作**

### 功能描述
提供文件和目录的创建、读取、写入、删除等操作，支持同步和异步两种方式。

### 典型应用场景

#### 1. 配置文件读写
```javascript
const fs = require('fs').promises;

// 读取应用配置
async function loadConfig() {
    try {
        const configData = await fs.readFile('./config.json', 'utf8');
        return JSON.parse(configData);
    } catch (error) {
        // 如果配置文件不存在，创建默认配置
        const defaultConfig = { port: 3000, database: 'mongodb://localhost/app' };
        await fs.writeFile('./config.json', JSON.stringify(defaultConfig, null, 2));
        return defaultConfig;
    }
}
```

#### 2. 日志记录系统
```javascript
const fs = require('fs');
const path = require('path');

class Logger {
    constructor(logDir = './logs') {
        this.logDir = logDir;
        this.ensureLogDirectory();
    }

    ensureLogDirectory() {
        if (!fs.existsSync(this.logDir)) {
            fs.mkdirSync(this.logDir, { recursive: true });
        }
    }

    log(message, level = 'INFO') {
        const timestamp = new Date().toISOString();
        const logMessage = `[${timestamp}] ${level}: ${message}\n`;
        const logFile = path.join(this.logDir, `${new Date().toDateString()}.log`);
        
        // 异步写入，不阻塞主线程
        fs.appendFile(logFile, logMessage, (err) => {
            if (err) console.error('日志写入失败:', err);
        });
    }
}
```

#### 3. 静态文件服务（Web服务器）
```javascript
const http = require('http');
const fs = require('fs');
const path = require('path');

const server = http.createServer(async (req, res) => {
    let filePath = '.' + req.url;
    if (filePath === './') filePath = './index.html';

    try {
        const content = await fs.promises.readFile(filePath);
        const ext = path.extname(filePath);
        const contentType = {
            '.html': 'text/html',
            '.css': 'text/css',
            '.js': 'application/javascript',
            '.json': 'application/json',
            '.png': 'image/png'
        }[ext] || 'text/plain';

        res.writeHead(200, { 'Content-Type': contentType });
        res.end(content);
    } catch (error) {
        res.writeHead(404);
        res.end('文件未找到');
    }
});
```

## 🌊 **stream 模块 - 流式数据处理**

### 功能描述
提供处理流数据的抽象接口，用于高效处理大量数据，避免内存溢出。

### 典型应用场景

#### 1. 大文件处理
```javascript
const fs = require('fs');
const { Transform } = require('stream');

// 大文件复制（内存友好）
function copyLargeFile(source, destination) {
    return new Promise((resolve, reject) => {
        const readStream = fs.createReadStream(source);
        const writeStream = fs.createWriteStream(destination);

        readStream.pipe(writeStream);
        
        writeStream.on('finish', resolve);
        writeStream.on('error', reject);
        readStream.on('error', reject);
    });
}

// 流式文件处理：实时压缩/加密
const zlib = require('zlib');
function compressFile(inputPath, outputPath) {
    return fs.createReadStream(inputPath)
        .pipe(zlib.createGzip())
        .pipe(fs.createWriteStream(outputPath));
}
```

#### 2. 实时数据处理管道
```javascript
const { Transform, pipeline } = require('stream');

// 自定义转换流：数据清洗
class DataCleaner extends Transform {
    _transform(chunk, encoding, callback) {
        try {
            // 移除特殊字符，转换为大写
            const cleaned = chunk.toString()
                .replace(/[^a-zA-Z0-9\s]/g, '')
                .toUpperCase();
            this.push(cleaned);
            callback();
        } catch (error) {
            callback(error);
        }
    }
}

// 数据处理管道
const cleaner = new DataCleaner();
fs.createReadStream('./raw-data.txt')
    .pipe(cleaner)
    .pipe(fs.createWriteStream('./cleaned-data.txt'))
    .on('finish', () => console.log('数据处理完成'));
```

#### 3. HTTP请求/响应流式处理
```javascript
const http = require('http');
const fs = require('fs');

// 流式视频播放
http.createServer((req, res) => {
    const videoPath = './sample.mp4';
    const stat = fs.statSync(videoPath);
    const fileSize = stat.size;
    const range = req.headers.range;

    if (range) {
        // 支持断点续传
        const parts = range.replace(/bytes=/, "").split("-");
        const start = parseInt(parts[0], 10);
        const end = parts[1] ? parseInt(parts[1], 10) : fileSize - 1;
        const chunksize = (end - start) + 1;
        
        const file = fs.createReadStream(videoPath, { start, end });
        const head = {
            'Content-Range': `bytes ${start}-${end}/${fileSize}`,
            'Accept-Ranges': 'bytes',
            'Content-Length': chunksize,
            'Content-Type': 'video/mp4',
        };
        
        res.writeHead(206, head);
        file.pipe(res);
    } else {
        // 完整文件传输
        const head = {
            'Content-Length': fileSize,
            'Content-Type': 'video/mp4',
        };
        res.writeHead(200, head);
        fs.createReadStream(videoPath).pipe(res);
    }
});
```

## 👶 **child_process 模块 - 子进程管理**

### 功能描述
用于创建和管理子进程，执行系统命令、其他脚本或CPU密集型任务。

### 典型应用场景

#### 1. 执行系统命令和Shell脚本
```javascript
const { exec, spawn } = require('child_process');

// 执行简单的系统命令
exec('ls -la', (error, stdout, stderr) => {
    if (error) {
        console.error(`执行错误: ${error}`);
        return;
    }
    console.log(`目录内容:\n${stdout}`);
});

// 执行复杂的Shell脚本
function runShellScript(scriptPath, args = []) {
    return new Promise((resolve, reject) => {
        const child = spawn('bash', [scriptPath, ...args]);
        
        let output = '';
        let errorOutput = '';

        child.stdout.on('data', (data) => {
            output += data.toString();
            console.log(`STDOUT: ${data}`);
        });

        child.stderr.on('data', (data) => {
            errorOutput += data.toString();
            console.error(`STDERR: ${data}`);
        });

        child.on('close', (code) => {
            if (code === 0) {
                resolve(output);
            } else {
                reject(new Error(`脚本执行失败，退出码: ${code}\n${errorOutput}`));
            }
        });
    });
}
```

#### 2. CPU密集型任务分离
```javascript
const { fork } = require('child_process');

// 主进程：创建子进程处理计算任务
function calculateFibonacci(n) {
    return new Promise((resolve, reject) => {
        const child = fork('./fibonacci-worker.js');
        
        child.send({ number: n });
        
        child.on('message', (result) => {
            resolve(result);
            child.kill(); // 任务完成，清理子进程
        });
        
        child.on('error', reject);
        
        // 设置超时保护
        setTimeout(() => {
            child.kill();
            reject(new Error('计算超时'));
        }, 10000);
    });
}

// fibonacci-worker.js - 子进程文件
process.on('message', (data) => {
    const result = fibonacci(data.number);
    process.send(result);
});

function fibonacci(n) {
    if (n <= 1) return n;
    return fibonacci(n - 1) + fibonacci(n - 2);
}
```

#### 3. 多进程任务并行处理
```javascript
const { Worker, isMainThread, parentPort, workerData } = require('worker_threads');

// 主进程：任务分发
if (isMainThread) {
    function parallelProcessTasks(tasks, workerCount = 4) {
        return new Promise((resolve) => {
            const chunkSize = Math.ceil(tasks.length / workerCount);
            const workers = [];
            let completedWorkers = 0;
            const results = [];

            for (let i = 0; i < workerCount; i++) {
                const workerTasks = tasks.slice(i * chunkSize, (i + 1) * chunkSize);
                
                const worker = new Worker(__filename, {
                    workerData: { tasks: workerTasks, workerId: i }
                });

                worker.on('message', (result) => {
                    results.push(...result);
                    completedWorkers++;
                    
                    if (completedWorkers === workerCount) {
                        resolve(results);
                    }
                });

                workers.push(worker);
            }
        });
    }
} else {
    // 子线程：任务处理
    const processedResults = workerData.tasks.map(task => ({
        ...task,
        processedBy: workerData.workerId,
        processedAt: new Date().toISOString()
    }));
    
    parentPort.postMessage(processedResults);
}
```

#### 4. 外部工具集成
```javascript
const { spawn } = require('child_process');
const path = require('path');

// 集成ImageMagick进行图片处理
function convertImage(inputPath, outputPath, format = 'jpeg') {
    return new Promise((resolve, reject) => {
        const args = [
            inputPath,
            '-resize', '50%',          // 缩放50%
            '-quality', '85',          // 质量85%
            `${format}:${outputPath}`  // 输出格式和路径
        ];

        const convert = spawn('convert', args);
        
        let stderr = '';
        convert.stderr.on('data', (data) => {
            stderr += data.toString();
        });

        convert.on('close', (code) => {
            if (code === 0) {
                resolve(`图片转换成功: ${outputPath}`);
            } else {
                reject(new Error(`ImageMagick转换失败: ${stderr}`));
            }
        });

        convert.on('error', (error) => {
            reject(new Error(`无法启动ImageMagick: ${error.message}`));
        });
    });
}
```

## 🎯 **模块选择指南**

| 场景 | 推荐模块 | 原因 |
|------|----------|------|
| 读写小文件 | **fs** | 简单直接，代码清晰 |
| 处理大文件 | **stream** | 内存效率高，不会溢出 |
| 实时数据处理 | **stream** | 低延迟，管道式处理 |
| 执行系统命令 | **child_process** | 必要的系统交互 |
| CPU密集型任务 | **child_process** | 避免阻塞事件循环 |
| 并行任务处理 | **child_process** + Worker | 充分利用多核CPU |

这三个模块构成了Node.js处理I/O操作、数据流和系统交互的核心能力，正确选择和使用它们可以显著提升应用性能和稳定性。