<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root"></div>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-presets="env,react">

        /** @jsx createElement */
        /** @jsxFrag Fragment */
        function createElement(type, config, ...children) {
            const props = {}
            let key = null, ref = null
            if (config) {
                Object.keys(config).forEach(name => {
                    if (name === 'key') {
                        key = config[name] + ''
                    } else if (name === 'ref') {
                        ref = config[name]
                    } else {
                        props[name] = config[name]
                    }
                })
            }
            if (children.length) {
                props.children = children.length === 1 ? children[0] : children
            }
            return { type, props, key, ref }
        }
        const Sync = (1 << 30) - 1;

        // scheduleWork
        let nextUnitOfWork = null
        let nextRoot = null
        let nextEffect = null


        let isCommitting = false
        let isWorking = false
        let isRendering = false

        // fiber tags
        const HostRoot = 0
        const HostComponent = 1
        const HostText = 2
        const FunctionComponent = 3
        const Fragment = 4

        //fiber effect tags
        const NoEffect = 0
        const Placement = 1 << 1
        const Update = 1 << 2
        const PlacementAndUpdate = Update | Placement
        const Deletion = 1 << 3
        const ContentReset = 1 << 4
        const Callback = 1 << 5
        const HostEffectMask = (1 << 9) - 1
        const Incomplete = 1 << 9

        //updateQueue update tags
        const UpdateState = 0;
        const ReplaceState = 1;
        const ForceUpdate = 2;
        const CaptureUpdate = 3;

        function createFiber(tag, pendingProps, key) {
            return {
                tag,
                type: null,
                elementType: null,
                key: key === undefined ? null : key,
                stateNode: null,

                return: null,
                child: null,
                sibling: null,
                index: 0,

                ref: null,

                pendingProps,
                memoizedProps: null,
                memoizedState: null,
                updateQueue: null,

                effectTag: NoEffect,
                nextEffect: null,

                firstEffect: null,
                lastEffect: null,

                alternate: null,

                expirationTime: 0,
                childExpirationTime: 0

            }
        }
        function createUpdate(expirationTime) {
            return {
                expirationTime: expirationTime,

                tag: UpdateState,
                payload: null,
                callback: null,

                next: null,
                nextEffect: null,
            };
        }
        function appendUpdateToQueue(
            queue,
            update,
        ) {
            // Append the update to the end of the list.
            if (queue.lastUpdate === null) {
                // Queue is empty
                queue.firstUpdate = queue.lastUpdate = update;
            } else {
                queue.lastUpdate.next = update;
                queue.lastUpdate = update;
            }
        }

        function cloneUpdateQueue(
            currentQueue,
        ) {
            const queue = {
                baseState: currentQueue.baseState,
                firstUpdate: currentQueue.firstUpdate,
                lastUpdate: currentQueue.lastUpdate,

                // TODO: With resuming, if we bail out and resuse the child tree, we should
                // keep these effects.
                firstCapturedUpdate: null,
                lastCapturedUpdate: null,

                firstEffect: null,
                lastEffect: null,

                firstCapturedEffect: null,
                lastCapturedEffect: null,
            };
            return queue;
        }
        function enqueueUpdate(fiber, update) {
            const alternate = fiber.alternate;
            let queue1;
            let queue2;
            if (alternate === null) {
                // There's only one fiber.
                queue1 = fiber.updateQueue;
                queue2 = null;
                if (queue1 === null) {
                    queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
                }
            } else {
                // There are two owners.
                queue1 = fiber.updateQueue;
                queue2 = alternate.updateQueue;
                if (queue1 === null) {
                    if (queue2 === null) {
                        // Neither fiber has an update queue. Create new ones.
                        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
                        queue2 = alternate.updateQueue = createUpdateQueue(
                            alternate.memoizedState,
                        );
                    } else {
                        // Only one fiber has an update queue. Clone to create a new one.
                        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
                    }
                } else {
                    if (queue2 === null) {
                        // Only one fiber has an update queue. Clone to create a new one.
                        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
                    } else {
                        // Both owners have an update queue.
                    }
                }
            }
            if (queue2 === null || queue1 === queue2) {
                // There's only a single queue.
                appendUpdateToQueue(queue1, update);
            } else {
                // There are two queues. We need to append the update to both queues,
                // while accounting for the persistent structure of the list — we don't
                // want the same update to be added multiple times.
                if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
                    // One of the queues is not empty. We must add the update to both queues.
                    appendUpdateToQueue(queue1, update);
                    appendUpdateToQueue(queue2, update);
                } else {
                    // Both queues are non-empty. The last update is the same in both lists,
                    // because of structural sharing. So, only append to one of the lists.
                    appendUpdateToQueue(queue1, update);
                    // But we still need to update the `lastUpdate` pointer of queue2.
                    queue2.lastUpdate = update;
                }
            }
        }
        function createUpdateQueue(baseState) {
            const queue = {
                baseState,
                firstUpdate: null,
                lastUpdate: null,
                firstCapturedUpdate: null,
                lastCapturedUpdate: null,
                firstEffect: null,
                lastEffect: null,
                firstCapturedEffect: null,
                lastCapturedEffect: null,
            };
            return queue;
        }
        function createWorkInProgress(fiber, pendingProps) {
            let workInProgress = fiber.alternate
            if (workInProgress === null) {
                workInProgress = createFiber(fiber.tag, pendingProps, fiber.key)
                workInProgress.alternate = fiber
                fiber.alternate = workInProgress
            } else {
                workInProgress.pendingProps = pendingProps
            }
            Object.assign(workInProgress, fiber)
            workInProgress.effectTag = NoEffect
            workInProgress.nextEffect = null
            workInProgress.lastEffect = null
            workInProgress.firstEffect = null
            return workInProgress
        }
        function createFiberFromTypeAndProps(type, key, pendingProps) {
            let fiber;

            let fiberTag = FunctionComponent;
            // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
            let resolvedType = type;
            if (typeof type === 'string') {
                fiberTag = HostComponent;
            } else {
                getTag: switch (type) {
                    case Fragment:
                        return createFiber(Fragment, pendingProps.children, key);
                    default: {
                        // if (typeof type === 'object' && type !== null) {
                        //     switch (type.$$typeof) {
                        //         case REACT_PROVIDER_TYPE:
                        //             fiberTag = ContextProvider;
                        //             break getTag;
                        //         case REACT_CONTEXT_TYPE:
                        //             // This is a consumer
                        //             fiberTag = ContextConsumer;
                        //             break getTag;
                        //         case REACT_FORWARD_REF_TYPE:
                        //             fiberTag = ForwardRef;
                        //             break getTag;
                        //         case REACT_MEMO_TYPE:
                        //             fiberTag = MemoComponent;
                        //             break getTag;
                        //         case REACT_LAZY_TYPE:
                        //             fiberTag = LazyComponent;
                        //             resolvedType = null;
                        //             break getTag;
                        //     }
                        // } 
                        break

                    }
                }
            }

            fiber = createFiber(fiberTag, pendingProps, key);
            fiber.elementType = type;
            fiber.type = resolvedType;
            return fiber;
        }
        function createFiberFromElement(element) {
            const type = element.type;
            const key = element.key;
            const pendingProps = element.props;
            const fiber = createFiberFromTypeAndProps(type, key, pendingProps)
            return fiber
        }

        function getRoot(fiber) {
            let current = fiber
            while (current) {
                if (current.tag === HostRoot) {
                    return current
                }
                current = current.return
            }
            return null
        }

        function workLoop() {
            while (nextUnitOfWork !== null) {
                nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
            }
        }
        function performUnitOfWork(workInProgress) {
            const current = workInProgress.alternate;

            const next = beginWork(current, workInProgress)
        }
        function beginWork(current, workInProgress) {

        }
        function renderRoot(root) {
            nextRoot = root;
            nextUnitOfWork = createWorkInProgress(nextRoot.current, null);
            do {
                try {
                    workLoop()
                } catch (e) {

                    if (nextUnitOfWork) {
                        let sibling = nextUnitOfWork.sibling
                        if (sibling) {
                            nextUnitOfWork = sibling
                            continue
                        }
                    }
                }
                break
            } while (true)
            if (nextUnitOfWork !== null) {
                // 没完成
                console.log('performWorkOnRoot:没完成')
                return
            }
            const rootWorkInProgress = root.current.alternate;
            onComplete(root, root.finishedWork)
        }
        function onComplete(root, finishedWork) {
            root.finishedWork = finishedWork
        }
        function performWorkOnRoot(root) {
            let finishedWork = root.finishedWork
            if (finishedWork !== null) {
                completeRoot(root, finishedWork)
            } else {
                root.finishedWork = null
                renderRoot(root)
                finishedWork = root.finishedWork
                if (finishedWork !== null) {
                    completeRoot(root, finishedWork)
                }
            }
        }
        function completeRoot(root, finishedWork) {
            root.finishedWork = null;
            commitRoot(root, finishedWork);
        }
        function commitRoot(root, finishedWork) {
            let firstEffect = finishedWork.firstEffect
            nextEffect = firstEffect;

            while (nextEffect !== null) {

            }

            onCommit(root)
        }
        function onCommit(root) {
            root.finishedWork = null
        }
        function performSyncWork() {

        }

        function addRootToSchedule(root, expirationTime) {
            // Add the root to the schedule.
            // Check if this root is already part of the schedule.
            if (root.nextScheduledRoot === null) {
                // This root is not already scheduled. Add it.
                root.expirationTime = expirationTime;
                if (lastScheduledRoot === null) {
                    firstScheduledRoot = lastScheduledRoot = root;
                    root.nextScheduledRoot = root;
                } else {
                    lastScheduledRoot.nextScheduledRoot = root;
                    lastScheduledRoot = root;
                    lastScheduledRoot.nextScheduledRoot = firstScheduledRoot;
                }
            } else {
                // This root is already scheduled, but its priority may have increased.
                const remainingExpirationTime = root.expirationTime;
                if (expirationTime > remainingExpirationTime) {
                    // Update the priority.
                    root.expirationTime = expirationTime;
                }
            }
        }
        function scheduleWorkToRoot(fiber, expirationTime) {
            if (fiber.expirationTime < expirationTime) {
                fiber.expirationTime = expirationTime;
            }
            let alternate = fiber.alternate;
            if (alternate !== null && alternate.expirationTime < expirationTime) {
                alternate.expirationTime = expirationTime;
            }
            let node = fiber.return;
            let root = null;
            if (node === null && fiber.tag === HostRoot) {
                root = fiber.stateNode;
            } else {
                while (node !== null) {
                    alternate = node.alternate;
                    if (node.childExpirationTime < expirationTime) {
                        node.childExpirationTime = expirationTime;
                        if (
                            alternate !== null &&
                            alternate.childExpirationTime < expirationTime
                        ) {
                            alternate.childExpirationTime = expirationTime;
                        }
                    } else if (
                        alternate !== null &&
                        alternate.childExpirationTime < expirationTime
                    ) {
                        alternate.childExpirationTime = expirationTime;
                    }
                    if (node.return === null && node.tag === HostRoot) {
                        root = node.stateNode;
                        break;
                    }
                    node = node.return;
                }
            }
            return root;
        }
        function requestWork(fiber, expirationTime) {
            console.log('requestWork')
            addRootToSchedule(fiber, expirationTime)
            if (isRendering) {
                return
            }
            performSyncWork()
        }
        function scheduleWork(fiber, expirationTime) {
            console.log('scheduleWork')
            const root = scheduleWorkToRoot(fiber, expirationTime);

            if (
                // If we're in the render phase, we don't need to schedule this root
                // for an update, because we'll do it before we exit...
                !isWorking ||
                isCommitting ||
                // ...unless this is a different root than the one we're rendering.
                nextRoot !== root
            ) {
                const rootExpirationTime = root.expirationTime;
                requestWork(root, rootExpirationTime);
            }
        }

        function render(element, container) {
            const fiberRoot = {
                finishedWork: null,
                context: null,
                containerInfo: container,
                current: null
            }
            const rootFiber = createFiber(HostRoot, null)
            rootFiber.stateNode = fiberRoot
            fiberRoot.current = rootFiber

            const update = createUpdate(Sync)
            update.payload = {
                element
            }
            //flushPassiveEffects()
            enqueueUpdate(rootFiber, update)
            scheduleWork(rootFiber, Sync)
        }
        function App() {
            return <h1>Hello World</h1>
        }
        render(<App></App>, document.querySelector('#root'))
    </script>
</body>

</html>