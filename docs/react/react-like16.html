<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <div id="root"></div>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script type="text/babel" data-presets="env,react">

        /** @jsx createElement */
        /** @jsxFrag Fragment */
        function createElement(type, config, ...children) {
            const props = {}
            let key = null, ref = null
            if (config) {
                Object.keys(config).forEach(name => {
                    if (name === 'key') {
                        key = config[name] + ''
                    } else if (name === 'ref') {
                        ref = config[name]
                    } else {
                        props[name] = config[name]
                    }
                })
            }
            if (children.length) {
                props.children = children.length === 1 ? children[0] : children
            }
            return { type, props, key, ref }
        }
        let nextUnitOfWork = null
        let nextRoot = null
        let nextEffect=null

        const HostRoot = 0
        const HostComponent = 1
        const HostText = 2
        const FunctionComponent = 3
        const Fragment = 4

        const NoEffect = 0
        const Placement = 1 << 1
        const Update = 1 << 2
        const PlacementAndUpdate = Update | Placement
        const Deletion = 1 << 3
        const ContentReset = 1 << 4
        const Callback = 1 << 5
        const HostEffectMask = (1 << 9) - 1
        const Incomplete = 1 << 9
        function createFiber(tag, pendingProps, key) {
            return {
                tag,
                type: null,
                elementType: null,
                key: key === undefined ? null : key,
                stateNode: null,

                return: null,
                child: null,
                sibling: null,
                index: 0,

                ref: null,

                pendingProps,
                memoizedProps: null,
                memoizedState: null,
                updateQueue: null,

                effectTag: NoEffect,
                nextEffect: null,

                firstEffect: null,
                lastEffect: null,

                alternate: null

            }
        }
        function createWorkInProgress(fiber, pendingProps) {
            let workInProgress = fiber.alternate
            if (workInProgress === null) {
                workInProgress = createFiber(fiber.tag, pendingProps, fiber.key)
                workInProgress.alternate = fiber
                fiber.alternate = workInProgress
            } else {
                workInProgress.pendingProps = pendingProps
            }
            Object.assign(workInProgress, fiber)
            workInProgress.effectTag = NoEffect
            workInProgress.nextEffect = null
            workInProgress.lastEffect = null
            workInProgress.firstEffect = null
            return workInProgress
        }
        function createFiberFromTypeAndProps(type, key, pendingProps) {
            let fiber;

            let fiberTag = FunctionComponent;
            // The resolved type is set if we know what the final type will be. I.e. it's not lazy.
            let resolvedType = type;
            if (typeof type === 'string') {
                fiberTag = HostComponent;
            } else {
                getTag: switch (type) {
                    case Fragment:
                        return createFiber(Fragment, pendingProps.children, key);
                    default: {
                        // if (typeof type === 'object' && type !== null) {
                        //     switch (type.$$typeof) {
                        //         case REACT_PROVIDER_TYPE:
                        //             fiberTag = ContextProvider;
                        //             break getTag;
                        //         case REACT_CONTEXT_TYPE:
                        //             // This is a consumer
                        //             fiberTag = ContextConsumer;
                        //             break getTag;
                        //         case REACT_FORWARD_REF_TYPE:
                        //             fiberTag = ForwardRef;
                        //             break getTag;
                        //         case REACT_MEMO_TYPE:
                        //             fiberTag = MemoComponent;
                        //             break getTag;
                        //         case REACT_LAZY_TYPE:
                        //             fiberTag = LazyComponent;
                        //             resolvedType = null;
                        //             break getTag;
                        //     }
                        // } 
                        break

                    }
                }
            }

            fiber = createFiber(fiberTag, pendingProps, key);
            fiber.elementType = type;
            fiber.type = resolvedType;
            return fiber;
        }
        function createFiberFromElement(element) {
            const type = element.type;
            const key = element.key;
            const pendingProps = element.props;
            const fiber = createFiberFromTypeAndProps(type, key, pendingProps)
            return fiber
        }

        function getRoot(fiber) {
            let current = fiber
            while (current) {
                if (current.tag === HostRoot) {
                    return current
                }
                current = current.return
            }
            return null
        }

        function workLoop() {
            while (nextUnitOfWork !== null) {
                nextUnitOfWork = performUnitOfWork(nextUnitOfWork)
            }
        }
        function performUnitOfWork(workInProgress) {
            const current = workInProgress.alternate;

            const next = beginWork(current, workInProgress)
        }
        function beginWork(current, workInProgress) {

        }
        function renderRoot(root) {
            nextRoot = root;
            nextUnitOfWork = createWorkInProgress(nextRoot.current, null);
            do {
                try {
                    workLoop()
                } catch (e) {

                    if (nextUnitOfWork) {
                        let sibling = nextUnitOfWork.sibling
                        if (sibling) {
                            nextUnitOfWork = sibling
                            continue
                        }
                    }
                }
                break
            } while (true)
            if (nextUnitOfWork !== null) {
                // 没完成
                console.log('performWorkOnRoot:没完成')
                return
            }
            const rootWorkInProgress = root.current.alternate;
            onComplete(root, root.finishedWork)
        }
        function onComplete(root, finishedWork) {
            root.finishedWork = finishedWork
        }
        function performWorkOnRoot(root) {
            let finishedWork = root.finishedWork
            if (finishedWork !== null) {
                completeRoot(root, finishedWork)
            } else {
                root.finishedWork = null
                renderRoot(root)
                finishedWork = root.finishedWork
                if (finishedWork !== null) {
                    completeRoot(root, finishedWork)
                }
            }
        }
        function completeRoot(root, finishedWork) {
                root.finishedWork = null;
                 commitRoot(root, finishedWork);
        }
        function commitRoot(root,finishedWork){
            let firstEffect=finishedWork.firstEffect
            nextEffect = firstEffect;

            while(nextEffect!==null){
                
            }

            onCommit(root)
        }
        function onCommit(root){
            root.finishedWork=null
        }
        function scheduleWork(fiber) {
            let hostRoot = getRoot(fiber)
            if(hostRoot){
                performWorkOnRoot(hostRoot.stateNode)
            }
        }
        function render(element, container) {
            const root = {
                finishedWork: null,
                container: container,
                current: null
            }
            const hostRoot = createFiber(HostRoot, null)
            hostRoot.memoizedState = { element }
            hostRoot.stateNode=root

            root.current=hostRoot
            scheduleWork(hostRoot)
        }
        function App() {
            return <h1>Hello World</h1>
        }
        render(<App></App>, document.querySelector('#root'))
    </script>
</body>

</html>