<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>MiniReact Pro — Full: Hooks / LIS Diff / Delegation / Scheduler / Fiber / ErrorBoundary / Suspense</title>
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto; padding: 18px; }
    .card { padding: 12px; border: 1px solid #ddd; border-radius: 8px; width: 920px; }
    .row { margin: 8px 0; }
    button { margin-right: 8px; }
    .suspense { padding:8px; border-radius:6px; background:#f4f7ff; }
    .error { padding:8px; border-radius:6px; background:#ffecec; color:#900; }
  </style>
</head>
<body>
  <h2>MiniReact Pro — All features demo</h2>
  <div id="app" class="card"></div>

<script>
/* ===================== MiniReact Pro =====================
   Features:
   - createElement (JSX pragma compatible)
   - Hooks (state, reducer, ref, memo, callback, effects, imperative handle, context)
   - Fiber + cooperative scheduler (priority levels)
   - Reconciler with keyed diff + LIS for minimal moves
   - Event delegation
   - ErrorBoundary
   - Suspense-like: throw Promise in render to suspend and show fallback
   - Demo app showing features
   ======================================================== */

/* ---------------- Utilities ---------------- */
const isFn = v => typeof v === 'function';
const isStr = v => typeof v === 'string' || typeof v === 'number';
const RESERVED = { children: true, key: true, ref: true };

/* ---------------- JSX support ----------------
 If you have Babel/TSX, add at top of file to compile JSX:
 /** @jsx MiniReact.createElement *\/
*/
function createElement(type, props, ...children) {
  props = props || {};
  const flat = children.flat().map(c => (c === null || c === undefined) ? null : (isStr(c) ? String(c) : c));
  return { type, props: { ...props, children: flat } };
}

/* ---------------- Scheduler (priority + cooperative) ----------------
 Priority: 1 Immediate, 2 UserBlocking, 3 Normal, 4 Low
 We'll schedule tasks and yield based on timeRemaining or time budget.
*/
const Scheduler = (function() {
  const Immediate = 1, UserBlocking = 2, Normal = 3, Low = 4;
  let queue = [];
  let hostCB = null;

  function ensureHost() {
    if (typeof requestIdleCallback !== 'undefined') {
      return (cb) => requestIdleCallback(cb, { timeout: 50 });
    }
    // postMessage fallback
    const channel = new MessageChannel();
    const tasks = [];
    channel.port1.onmessage = () => {
      const t = tasks.shift();
      if (t) t({ timeRemaining: () => 5, didTimeout: false, startTime: performance.now(), timeout: 50 });
    };
    return (cb) => {
      tasks.push(cb);
      channel.port2.postMessage(null);
    };
  }
  hostCB = ensureHost();

  function schedule(task, priority = Normal) {
    queue.push({ task, priority });
    // sort by priority (simple)
    queue.sort((a,b) => a.priority - b.priority);
    hostCB(run);
  }

  function run(deadline) {
    const start = performance.now();
    while (queue.length) {
      const item = queue.shift();
      try { item.task(deadline); } catch (e) { console.error('Scheduled task error', e); }
      // yield heuristics
      if (deadline.timeRemaining && deadline.timeRemaining() < 2) break;
      if (performance.now() - start > 30) break;
    }
    if (queue.length) hostCB(run);
  }

  return { schedule, Immediate, UserBlocking, Normal, Low };
})();

/* ---------------- Event Delegation ----------------
  We'll attach listener(s) to root container and dispatch to VNode props.
  We map DOM node -> fiber via dataset attribute.
*/
const Delegator = (function() {
  const delegatedTypes = new Set();
  const rootMap = new WeakMap(); // container -> attached
  function ensureRoot(container) {
    if (!rootMap.has(container)) {
      rootMap.set(container, { handlers: {} });
    }
    return rootMap.get(container);
  }
  function addEvent(container, eventName) {
    const root = ensureRoot(container);
    if (delegatedTypes.has(eventName)) return;
    delegatedTypes.add(eventName);
    container.addEventListener(eventName, (ev) => {
      // walk up from ev.target to container, find the nearest dom with data-mini-id and call handlers on fiber vnode mapping
      let node = ev.target;
      while (node && node !== container) {
        const id = node.__mini_fiber_id;
        if (id) {
          const handler = node.__mini_handlers && node.__mini_handlers[eventName];
          if (handler) {
            try { handler.call(node, ev); } catch (e) { console.error(e); }
            if (ev.cancelBubble) return;
          }
        }
        node = node.parentNode;
      }
    }, false);
  }
  function updateNodeHandlers(dom, props) {
    // store handlers in dom for delegation
    dom.__mini_handlers = dom.__mini_handlers || {};
    for (const k in props) {
      if (/^on[A-Z]/.test(k)) {
        const event = k.slice(2).toLowerCase();
        dom.__mini_handlers[event] = props[k];
        addEvent(getRootContainer(dom), event);
      }
    }
  }
  function getRootContainer(dom) {
    // walk up to find element with mini root marker
    let node = dom;
    while (node && !node.__mini_root) node = node.parentNode;
    return node || document;
  }
  return { updateNodeHandlers };
})();

/* ---------------- Fiber & Renderer State ----------------
 Fiber: { vnode, type, props, dom, parent, child, sibling, alternate, effectTag, hooks, effects, key }
*/
let nextUnitOfWork = null;
let wipRoot = null;
let currentRoot = null;
let deletions = [];
let fiberId = 1; // used to tag DOM nodes for delegation

/* ---------------- Hooks (attached to fiber) ---------------- */
let wipFiber = null;
let hookIndex = 0;
function prepareHooks(fiber) {
  wipFiber = fiber;
  hookIndex = 0;
  if (!wipFiber.hooks) wipFiber.hooks = [];
}
function useHookSlot() {
  if (!wipFiber) throw new Error('Hooks can only be called inside function components.');
  const idx = hookIndex++;
  if (!wipFiber.hooks[idx]) wipFiber.hooks[idx] = { value: undefined };
  return wipFiber.hooks[idx];
}
function useState(initial) {
  const slot = useHookSlot();
  if (slot.value === undefined) slot.value = (isFn(initial) ? initial() : initial);
  const setState = (action) => {
    const next = (isFn(action) ? action(slot.value) : action);
    if (Object.is(next, slot.value)) return;
    slot.value = next;
    scheduleUpdate();
  };
  return [slot.value, setState];
}
function useReducer(reducer, initial, init) {
  const slot = useHookSlot();
  if (slot.value === undefined) slot.value = init ? init(initial) : initial;
  const dispatch = (action) => {
    const next = reducer(slot.value, action);
    if (Object.is(next, slot.value)) return;
    slot.value = next;
    scheduleUpdate();
  };
  return [slot.value, dispatch];
}
function useRef(initial = null) {
  const slot = useHookSlot();
  if (slot.value === undefined) slot.value = { current: initial };
  return slot.value;
}
function useMemo(factory, deps) {
  const slot = useHookSlot();
  const prev = slot.value;
  const same = prev && deps && prev.deps && deps.length === prev.deps.length && deps.every((d,i)=>Object.is(d, prev.deps[i]));
  if (!same) {
    const v = factory();
    slot.value = { value: v, deps: deps ? deps.slice() : undefined };
  }
  return slot.value.value;
}
function useCallback(fn, deps) { return useMemo(()=>fn, deps); }

/* Effects (collected on fiber) */
function useEffect(create, deps) {
  const slot = useHookSlot();
  const prev = slot.value;
  const same = prev && deps && prev.deps && deps.length === prev.deps.length && deps.every((d,i)=>Object.is(d, prev.deps[i]));
  if (!same) {
    slot.value = { create, deps, cleanup: prev && prev.cleanup };
    if (!wipFiber.effects) wipFiber.effects = [];
    wipFiber.effects.push({ type: 'effect', slot: slot.value });
  }
}
function useLayoutEffect(create, deps) {
  const slot = useHookSlot();
  const prev = slot.value;
  const same = prev && deps && prev.deps && deps.length === prev.deps.length && deps.every((d,i)=>Object.is(d, prev.deps[i]));
  if (!same) {
    slot.value = { create, deps, cleanup: prev && prev.cleanup };
    if (!wipFiber.effects) wipFiber.effects = [];
    wipFiber.effects.push({ type: 'layout', slot: slot.value });
  }
}
function useImperativeHandle(ref, factory, deps) {
  useLayoutEffect(() => {
    const inst = factory();
    if (ref) ref.current = inst;
    return () => { if (ref && ref.current === inst) ref.current = null; };
  }, deps);
}

/* Context */
function createContext(defaultValue) {
  const ctx = { _default: defaultValue, _value: defaultValue };
  function Provider(props) {
    ctx._value = props.value;
    return props.children && props.children.length ? props.children[0] : null;
  }
  ctx.Provider = Provider;
  return ctx;
}
function useContext(ctx) {
  return ctx._value !== undefined ? ctx._value : ctx._default;
}

/* ---------------- Suspense support ----------------
  If during rendering a component throws a Promise, we catch it and mark fiber as suspended.
  We render a fallback vnode in its place (provided via props.fallback on the Suspense component).
  When promise resolves, we retry by re-rendering root.
*/
function isPromise(x) { return x && typeof x.then === 'function'; }

/* ---------------- Reconciler helpers ---------------- */
function createDom(fiber) {
  if (isStr(fiber.vnode)) {
    const t = document.createTextNode(String(fiber.vnode));
    return t;
  }
  const type = fiber.vnode.type;
  if (typeof type === 'string') {
    const dom = document.createElement(type);
    // assign id for delegation
    dom.__mini_fiber_id = fiberId++;
    // store reference from dom to fiber
    dom.__mini_fiber = fiber;
    // set attributes
    updateDomProperties(dom, {}, fiber.vnode.props || {});
    return dom;
  }
  return null;
}
function updateDomProperties(dom, prevProps, nextProps) {
  prevProps = prevProps || {};
  nextProps = nextProps || {};
  // remove old
  for (const k in prevProps) {
    if (k === 'children') continue;
    if (!(k in nextProps)) setProp(dom, k, null);
  }
  // set new
  for (const k in nextProps) {
    if (k === 'children') continue;
    const prev = prevProps[k];
    const next = nextProps[k];
    if (prev !== next) setProp(dom, k, next);
  }
  // set up event delegation stored on DOM
  Delegator.updateNodeHandlers(dom, nextProps);
}
function setProp(dom, name, value) {
  if (name === 'style') {
    if (!value) dom.removeAttribute('style');
    else Object.assign(dom.style, value);
  } else if (/^on[A-Z]/.test(name)) {
    // handled by delegation; keep handler in dom.__mini_handlers via Delegator.updateNodeHandlers
  } else if (name === 'ref') {
    // handled in commit
  } else if (name in dom && !(dom instanceof SVGElement)) {
    if (value == null) dom.removeAttribute(name);
    else dom[name] = value;
  } else {
    if (value == null) dom.removeAttribute(name);
    else dom.setAttribute(name, value);
  }
}
function sameType(a, b) {
  if (a == null || b == null) return false;
  if (isStr(a) || isStr(b)) return (isStr(a) && isStr(b));
  return a.type === b.type;
}

/* ---------------- Keyed diff + LIS (for minimizing moves) ----------------
  We'll implement a reconcileChildren that:
  - Matches keyed children to old keyed
  - For non-keyed, uses index-based matching
  - For keyed children we compute newIndices -> oldIndex sequence and LIS to minimize moves
*/
function reconcileChildrenArray(parentFiber, elements) {
  // elements: array of vnode (may be string)
  let oldFiber = parentFiber.alternate && parentFiber.alternate.child;
  // collect old keyed map and old list
  const oldChildren = [];
  while (oldFiber) {
    oldChildren.push(oldFiber);
    oldFiber = oldFiber.sibling;
  }

  const keyedMap = new Map();
  const oldNoKey = [];
  for (const ofib of oldChildren) {
    const key = ofib.vnode && ofib.vnode.props && ofib.vnode.props.key;
    if (key != null) keyedMap.set(key, ofib);
    else oldNoKey.push(ofib);
  }

  // first pass: create fibermap for new elements
  const newFibers = [];
  for (let i = 0; i < elements.length; i++) {
    const el = elements[i];
    if (el == null) continue;
    const key = el.props && el.props.key;
    let matched = null;
    if (key != null) {
      matched = keyedMap.get(key);
      if (matched) keyedMap.delete(key);
    } else {
      matched = oldNoKey.shift() || null;
    }
    if (matched && sameType(matched.vnode, el)) {
      const nf = { vnode: el, dom: matched.dom, parent: parentFiber, alternate: matched, effectTag: 'UPDATE', key };
      newFibers.push(nf);
    } else {
      const nf = { vnode: el, dom: null, parent: parentFiber, alternate: null, effectTag: 'PLACEMENT', key };
      newFibers.push(nf);
    }
  }

  // leftovers are deletions
  for (const [,v] of keyedMap) deletions.push(v);
  for (const of of oldNoKey) deletions.push(of);

  // if no keys at all, simple re-link by index
  const hasKeyed = newFibers.some(f => f.key != null);
  if (!hasKeyed) {
    // attach as child/sibling
    let prev = null;
    for (let i = 0; i < newFibers.length; i++) {
      const nf = newFibers[i];
      if (prev) prev.sibling = nf;
      else parentFiber.child = nf;
      prev = nf;
    }
    return;
  }

  // For keyed case: use algorithm to minimize moves.
  // Build array of old indices in order of newFibers
  const oldIndexForNew = [];
  const oldList = oldChildren;
  const oldIndexMap = new Map();
  for (let i=0;i<oldList.length;i++) {
    const k = oldList[i].vnode && oldList[i].vnode.props && oldList[i].vnode.props.key;
    if (k != null) oldIndexMap.set(k, i);
  }
  for (let i=0;i<newFibers.length;i++) {
    const k = newFibers[i].key;
    if (k == null) oldIndexForNew.push(-1);
    else {
      const idx = oldIndexMap.has(k) ? oldIndexMap.get(k) : -1;
      oldIndexForNew.push(idx);
    }
  }

  // compute LIS on oldIndexForNew (ignoring -1)
  const seq = longestIncreasingSubsequence(oldIndexForNew);

  // mark which new positions are part of LIS (to keep)
  const keep = new Set(seq.map(i => i.index));

  // Apply: link siblings; mark effectTag: if dom exists and not kept -> MOVE (we'll treat as PLACEMENT+DELETE)
  let prev = null;
  for (let i=0;i<newFibers.length;i++) {
    const nf = newFibers[i];
    if (prev) prev.sibling = nf;
    else parentFiber.child = nf;
    prev = nf;
    if (nf.alternate && nf.alternate.dom) {
      if (!keep.has(i)) {
        nf.effectTag = 'PLACEMENT'; // requires move (we'll append and old will be deleted)
      } else {
        nf.effectTag = 'UPDATE';
      }
    } else {
      nf.effectTag = 'PLACEMENT';
    }
  }
}

/* Helper: LIS - returns sequence of {value,index} of LIS among numbers where -1 are ignored.
   Implementation returns indexes of the LIS in the array.
*/
function longestIncreasingSubsequence(arr) {
  const n = arr.length;
  const predecessors = new Array(n).fill(-1);
  const piles = [];
  const pileIdx = [];
  for (let i = 0; i < n; i++) {
    const val = arr[i];
    if (val === -1) continue;
    // binary search on piles by last value
    let left = 0, right = piles.length;
    while (left < right) {
      const mid = (left + right) >> 1;
      if (piles[mid][piles[mid].length-1].value < val) left = mid + 1;
      else right = mid;
    }
    if (left === piles.length) piles.push([]);
    piles[left].push({ value: val, index: i });
    if (left > 0) {
      predecessors[i] = piles[left-1][piles[left-1].length-1].index;
    }
  }
  // rebuild LIS
  if (piles.length === 0) return [];
  const lis = [];
  let last = piles[piles.length-1][piles[piles.length-1].length-1];
  let idx = last.index;
  while (idx !== -1) {
    lis.push({ value: arr[idx], index: idx });
    idx = predecessors[idx];
  }
  lis.reverse();
  return lis;
}

/* ---------------- Core work loop (fiber) ----------------
  performUnitOfWork builds fibers for one node, handling function components (hooks),
  host nodes, Suspense (promise thrown) and ErrorBoundary (exceptions)
*/
function performUnitOfWork(fiber) {
  try {
    // Function component
    if (typeof fiber.vnode.type === 'function') {
      // prepare hooks
      prepareHooks(fiber);
      // call component
      let children;
      try {
        children = fiber.vnode.type(fiber.vnode.props || {});
      } catch (thrown) {
        if (isPromise(thrown)) {
          // Suspension: render fallback if provided via fiber.vnode.props.fallback (if component is Suspense)
          // We'll mark fiber as suspended and attach promise to retry on resolve.
          fiber.suspended = true;
          thrown.then(() => scheduleUpdate()); // retry render when resolved
          // create fallback vnode if provided (we'll set as single child)
          const fallback = (fiber.vnode.props && fiber.vnode.props.fallback) || createElement('div', null, 'Loading...');
          children = fallback;
        } else {
          // If an error and there is an ErrorBoundary ancestor, bubble up by throwing to parent handling
          throw thrown;
        }
      }
      const childArray = children == null ? [] : (Array.isArray(children) ? children : [children]);
      reconcileChildrenArray(fiber, childArray);
    } else if (isStr(fiber.vnode)) {
      // text node - nothing to reconcile children-wise
      if (!fiber.dom) fiber.dom = createDom(fiber);
    } else if (typeof fiber.vnode.type === 'string') {
      // host node
      if (!fiber.dom) fiber.dom = createDom(fiber);
      const children = (fiber.vnode.props && fiber.vnode.props.children) || [];
      reconcileChildrenArray(fiber, children);
    } else {
      // null / unsupported - nothing
    }
  } catch (err) {
    // Error handling: find nearest ErrorBoundary up the tree (parent chain)
    let boundary = fiber.parent;
    while (boundary) {
      if (boundary.vnode && boundary.vnode.type && boundary.vnode.type.isErrorBoundary) break;
      boundary = boundary.parent;
    }
    if (boundary) {
      // mount fallback UI from ErrorBoundary.props.fallback or its renderError method
      boundary.error = err;
      // set its child to the fallback element
      const fallback = (boundary.vnode.props && boundary.vnode.props.fallback) || createElement('div', null, 'Error');
      reconcileChildrenArray(boundary, [fallback]);
      return null; // stop descending into branch
    } else {
      // no boundary -> rethrow (will show in console)
      console.error('Uncaught render error', err);
      throw err;
    }
  }

  // return next unit
  if (fiber.child) return fiber.child;
  let next = fiber;
  while (next) {
    if (next.sibling) return next.sibling;
    next = next.parent;
  }
  return null;
}

/* ---------------- Commit phase ---------------- */
function commitRoot() {
  deletions.forEach(commitWorkDeletion);
  commitWork(wipRoot.child);
  currentRoot = wipRoot;
  wipRoot = null;
  // after commit, run collected effects
  runEffects(currentRoot);
}
function commitWorkDeletion(fiber) {
  if (!fiber) return;
  if (fiber.dom) {
    const parentDom = findParentDom(fiber.parent);
    if (parentDom && fiber.dom.parentNode === parentDom) parentDom.removeChild(fiber.dom);
  } else {
    commitWorkDeletion(fiber.child);
  }
}
function commitWork(fiber) {
  if (!fiber) return;
  const parentDom = findParentDom(fiber.parent);

  if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {
    parentDom.appendChild(fiber.dom);
  } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {
    updateDomProperties(fiber.dom, fiber.alternate ? (fiber.alternate.vnode.props || {}) : {}, fiber.vnode.props || {});
  }
  // set ref
  if (fiber.dom && fiber.vnode && fiber.vnode.props && fiber.vnode.props.ref) {
    const r = fiber.vnode.props.ref;
    if (typeof r === 'function') r(fiber.dom);
    else if (typeof r === 'object') r.current = fiber.dom;
  }
  // attach dom.__mini_fiber to updated fiber
  if (fiber.dom) fiber.dom.__mini_fiber = fiber;

  commitWork(fiber.child);
  commitWork(fiber.sibling);
}
function findParentDom(fiber) {
  let parent = fiber;
  while (parent && !parent.dom) parent = parent.parent;
  return parent ? parent.dom : null;
}

/* Effects runner (layout sync, effect async) */
function runEffects(rootFiber) {
  const layout = [];
  const effects = [];
  function walk(f) {
    if (!f) return;
    if (f.effects) {
      for (const e of f.effects) {
        if (e.type === 'layout') layout.push(e.slot);
        else effects.push(e.slot);
      }
    }
    walk(f.child); walk(f.sibling);
  }
  walk(rootFiber);
  // layout effects sync
  for (const slot of layout) {
    try { if (slot.cleanup) slot.cleanup(); } catch (e) { console.error(e); }
    try { const ret = slot.create(); if (typeof ret === 'function') slot.cleanup = ret; } catch (e) { console.error(e); }
  }
  // normal effects async
  setTimeout(() => {
    for (const slot of effects) {
      try { if (slot.cleanup) slot.cleanup(); } catch (e) { console.error(e); }
      try { const ret = slot.create(); if (typeof ret === 'function') slot.cleanup = ret; } catch (e) { console.error(e); }
    }
  }, 0);
}

/* ---------------- Work loop scheduling ---------------- */
function workLoop(deadline) {
  while (nextUnitOfWork && (deadline.timeRemaining ? deadline.timeRemaining() > 1 : true)) {
    nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
  }
  if (!nextUnitOfWork && wipRoot) {
    // commit
    commitRoot();
  } else {
    // schedule remaining
    Scheduler.schedule(() => workLoop({ timeRemaining: () => 5 }), Scheduler.Normal);
  }
}

/* ---------------- Public render API ---------------- */
function render(vnode, container) {
  // mark container as root for delegation
  container.__mini_root = container;
  wipRoot = {
    vnode: { type: 'div', props: { children: [vnode] } }, // wrap
    dom: container,
    parent: null,
    alternate: currentRoot,
    effectTag: null,
    child: null
  };
  deletions = [];
  nextUnitOfWork = wipRoot;
  Scheduler.schedule(() => workLoop({ timeRemaining: () => 50 }), Scheduler.UserBlocking);
}
function scheduleUpdate() {
  if (!currentRoot) return;
  const rootVNode = currentRoot.vnode.props.children;
  render(rootVNode, currentRoot.dom);
}

/* ---------------- Export API ---------------- */
const MiniReact = {
  createElement,
  render,
  useState,
  useReducer,
  useRef,
  useMemo,
  useCallback,
  useEffect,
  useLayoutEffect,
  useImperativeHandle,
  createContext,
  useContext,
  // extras
  Scheduler,
};
window.MiniReact = MiniReact;

/* ---------------- Demo Application ---------------- */

/* Context */
const CountContext = createContext(0);

/* ErrorBoundary component */
function ErrorBoundary(props) {
  // mark as error boundary
  ErrorBoundary.isErrorBoundary = true;
  // if there's an error attached, render fallback
  const hasErr = props && props._internal && props._internal.error;
  if (hasErr) {
    return createElement('div', { className: 'error' }, 'Caught error: ', String(props._internal.error && props._internal.error.message || 'Error'));
  }
  // else render children
  return props.children && props.children.length ? props.children[0] : null;
}
ErrorBoundary.isErrorBoundary = true;

/* Suspense wrapper: component that expects its child to possibly throw a Promise in render.
   Accepts fallback prop.
*/
function Suspense(props) {
  // just render children normally - actual catching is in fiber try/catch
  return props.children && props.children.length ? props.children[0] : null;
}

/* Component that deliberately throws a Promise (simulate lazy loading) */
function AsyncText({ delay = 1000, text = 'Hello' }) {
  const [state] = useState(0); // just to use hooks
  // on render we create a promise and throw it if not ready
  if (!AsyncText.cache) AsyncText.cache = {};
  if (AsyncText.cache[text]) return AsyncText.cache[text];
  // create a promise that resolves after delay and set cache
  throw new Promise((res) => {
    setTimeout(() => {
      AsyncText.cache[text] = createElement('span', null, text + ' (loaded)');
      res();
      // after resolved schedule update
      scheduleUpdate();
    }, delay);
  });
}

/* Demo components using hooks and imperative handle */
function Counter() {
  const [n, setN] = useState(0);
  useEffect(()=> { console.log('Counter effect', n); return ()=>console.log('Counter cleanup', n); }, [n]);
  return createElement('div', { className: 'row' },
    `Count: ${n} `,
    createElement('button', { onclick: ()=>setN(x=>x+1) }, '+'),
    createElement('button', { onclick: ()=>setN(x=>x-1) }, '-')
  );
}

function BigList({ n }) {
  // heavy list to show scheduler interrupts & LIS diff on toggles
  const arr = [];
  for (let i = 0; i < n; i++) arr.push(createElement('div', { key: 'item-' + i, style: { padding: '2px 0' } }, 'Item #' + i));
  return createElement('div', null, ...arr);
}

function Editable({ onChangeRef }) {
  const ref = useRef();
  useImperativeHandle(onChangeRef, () => ({
    focus: () => ref.current && ref.current.focus(),
    value: () => ref.current && ref.current.value
  }), []);
  return createElement('input', { ref, oninput: (e)=>{ /* no-op, direct DOM event */ } });
}

function App() {
  const [providerCount, setProviderCount] = useState(1);
  const [showHeavy, setShowHeavy] = useState(false);
  const [listSize, setListSize] = useState(100);
  const impRef = useRef();
  const [showError, setShowError] = useState(false);
  const [suspendId, setSuspendId] = useState(0);

  return createElement('div', null,
    createElement('h3', null, 'MiniReact Pro — Demo'),
    createElement('div', { className: 'row' },
      createElement('button', { onclick: ()=>setProviderCount(x=>x+1) }, 'Inc Provider: ' + providerCount),
      createElement('button', { onclick: ()=>setShowHeavy(x=>!x) }, showHeavy ? 'Hide heavy' : 'Show heavy'),
      createElement('button', { onclick: ()=>setListSize(s=>s+50) }, 'Increase list size: ' + listSize),
      createElement('button', { onclick: ()=>setShowError(x=>!x) }, showError ? 'Clear error' : 'Trigger error'),
      createElement('button', { onclick: ()=>setSuspendId(id=>id+1) }, 'Reload async')
    ),
    createElement(CountContext.Provider, { value: providerCount },
      // ErrorBoundary usage
      createElement(ErrorBoundary, { fallback: createElement('div', null, 'Boundary fallback') },
        createElement('div', null,
          createElement(Counter, null),
          createElement('div', { className: 'row' }, 'Context value: ', createElement('strong', null, providerCount)),
          createElement(Editable, { onChangeRef: impRef }),
          createElement('div', { className: 'row' },
            createElement('button', { onclick: ()=>impRef.current && impRef.current.focus() }, 'Focus child input'),
            createElement('button', { onclick: ()=>console.log('Child value:', impRef.current && impRef.current.value()) }, 'Log child value')
          ),
          // Suspense example: child AsyncText will throw Promise first render
          createElement(Suspense, { fallback: createElement('div', { className:'suspense' }, 'Loading async...') },
            createElement('div', null,
              createElement(AsyncText, { delay: 1500, text: 'Async #' + suspendId }),
              createElement(AsyncText, { delay: 700, text: 'Quick #' + suspendId })
            )
          ),
          // show heavy list toggled
          showHeavy ? createElement(BigList, { n: listSize }) : null,
          // error trigger: a component that throws
          showError ? createElement(() => { throw new Error('Demo error'); }) : null
        )
      )
    )
  );
}

/* initial render */
render(createElement(App, null), document.getElementById('app'));

/* ---------------- Notes on usage & JSX ----------------
 - This demo uses createElement directly so it runs without compilation.
 - To use JSX with Babel/TSX, set the pragma at your file top:
   /** @jsx MiniReact.createElement *\/
   and compile — produced JSX will call MiniReact.createElement automatically.
 - Event props: use onClick -> becomes onClick in props; internally delegation maps onXxx handlers.
 - Suspense: wrap nodes with <Suspense fallback={...}>; inside, if a component throws a Promise, the fallback shows.
 - ErrorBoundary: provide a component with .isErrorBoundary = true (this demo provides ErrorBoundary function with that flag).
*/

/* expose for debugging */
window.MiniReact = MiniReact;

</script>
</body>
</html>
