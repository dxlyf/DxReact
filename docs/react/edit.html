<<<<<<< HEAD
<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Canvas Rich Text Editor - Fixed</title>
<style>
  html,body{height:100%;margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,'Noto Sans SC',sans-serif}
  .app{display:flex;flex-direction:column;height:100%}
  .toolbar{height:44px;display:flex;gap:6px;padding:6px;background:#f3f4f6;align-items:center}
  .toolbar button{height:32px;padding:0 8px;border:1px solid #ddd;background:#fff;border-radius:4px;cursor:pointer}
  .toolbar select,input[type=color]{height:28px}
  .editor-wrap{flex:1;display:flex}
  .canvas-wrap{flex:1;position:relative;background:#fff}
  canvas{width:100%;height:100%;display:block;background:#fff}
  #ime{position:absolute;opacity:0;left:0;top:0;width:1px;height:1px;border:0;padding:0;margin:0;resize:none}
  .status{width:240px;padding:8px;border-left:1px solid #eee;background:#fafafa}
</style>
</head>
<body>
<div class="app">
  <div class="toolbar" id="toolbar">
    <button id="btnBold"><b>B</b></button>
    <button id="btnItalic"><i>I</i></button>
    <button id="btnUnderline"><u>U</u></button>
    <select id="fontSize"><option value="14">14px</option><option value="16" selected>16px</option><option value="18">18px</option><option value="24">24px</option><option value="32">32px</option></select>
    <input type="color" id="fontColor" value="#000000">
    <button id="btnLeft">Left</button>
    <button id="btnCenter">Center</button>
    <button id="btnRight">Right</button>
    <button id="btnBullet">• List</button>
    <button id="btnUndo">Undo</button>
    <button id="btnRedo">Redo</button>
  </div>
  <div class="editor-wrap">
    <div class="canvas-wrap">
      <canvas id="editor"></canvas>
      <textarea id="ime" autofocus></textarea>
    </div>
    <div class="status">
      <div>Canvas Rich Text Editor Prototype (fixed)</div>
      <div style="margin-top:12px;font-size:12px;color:#666">Instructions:</div>
      <ul style="font-size:12px;color:#666">
        <li>单击画布定位光标或拖拽选取文本</li>
        <li>支持中文输入（通过隐藏 textarea），支持换行</li>
        <li>Ctrl/Cmd+B / I / U 切换样式，Ctrl+Z / Ctrl+Y 撤销/重做</li>
        <li>字体大小/颜色改变会应用到插入点或选区</li>
      </ul>
    </div>
  </div>
</div>

<script>
(function(){
  const canvas = document.getElementById('editor');
  const ime = document.getElementById('ime');
  const dpr = Math.max(1, window.devicePixelRatio || 1);
  const ctx = canvas.getContext('2d');

  function resize(){ canvas.width = canvas.clientWidth * dpr; canvas.height = canvas.clientHeight * dpr; ctx.setTransform(dpr,0,0,dpr,0,0); render(); }
  window.addEventListener('resize', resize);

  const state = {
    doc: [
      {
        // paragraph-level
        blocks: [
          { text: '欢迎使用 Canvas 富文本编辑器 原型。支持中文输入，换行，选择以及基本样式。', style:{bold:false,italic:false,underline:false,fontSize:16,color:'#000000'} }
        ],
        align:'left',
        list:false
      }
    ],
    caret: { block:0, offset:0 },
    sel: null,
    caretVisible:true,
    composing:false,
    tool: { bold:false, italic:false, underline:false, fontSize:16, color:'#000000', align:'left', list:false },
    undoStack:[], redoStack:[]
  };

  function pushUndo(){ state.undoStack.push(cloneStateForUndo()); if(state.undoStack.length>200) state.undoStack.shift(); state.redoStack.length=0; }
  function cloneStateForUndo(){ return JSON.parse(JSON.stringify({doc:state.doc, caret:state.caret, sel:state.sel})); }
  function restoreFromUndo(s){ state.doc = s.doc; state.caret = s.caret; state.sel = s.sel; }

  function normalizeSel(){ if(!state.sel) return null; const a = state.sel.start, b = state.sel.end; if(a.block < b.block || (a.block===b.block && a.offset<=b.offset)) return {start:a,end:b}; return {start:b,end:a}; }

  function insertTextAtCaret(str){
    pushUndo();
    if(state.sel){ deleteSelection(); }
    const p = state.doc[state.caret.block];
    // find run and offset across runs
    const {runIndex, runOffset} = findRunIndexAtOffset(p, state.caret.offset);
    const run = p.blocks[runIndex];
    const before = run.text.slice(0, runOffset);
    const after = run.text.slice(runOffset);
    run.text = before + str + after;
    state.caret.offset += str.length;
  }

  function deleteSelection(){
    const norm = normalizeSel();
    if(!norm) return;
    pushUndo();
    const {start,end} = norm;
    if(start.block === end.block){
      const p = state.doc[start.block];
      // remove range across runs
      const mergedText = removeRangeFromParagraph(p, start.offset, end.offset);
      // replace with single run preserving style of pre-range (simple)
      p.blocks = [{ text: mergedText, style: Object.assign({}, p.blocks[0].style) }];
      state.caret = { block: start.block, offset: start.offset };
      state.sel = null;
    } else {
      // merge start and end paragraphs (simplified)
      const pStart = state.doc[start.block];
      const pEnd = state.doc[end.block];
      const startText = substringParagraph(pStart, 0, start.offset);
      const endText = substringParagraph(pEnd, end.offset, paragraphLength(pEnd));
      pStart.blocks = [{ text: startText + endText, style: Object.assign({}, pStart.blocks[0].style) }];
      // remove intermediate paragraphs
      state.doc.splice(start.block+1, end.block - start.block);
      state.caret = { block: start.block, offset: start.offset };
      state.sel = null;
    }
  }

  function insertNewline(){
    pushUndo();
    const p = state.doc[state.caret.block];
    const before = substringParagraph(p, 0, state.caret.offset);
    const after = substringParagraph(p, state.caret.offset, paragraphLength(p));
    p.blocks = [{ text: before, style: Object.assign({}, p.blocks[0].style) }];
    const newP = { blocks: [{ text: after, style: Object.assign({}, p.blocks[0].style) }], align:p.align, list:false };
    state.doc.splice(state.caret.block+1, 0, newP);
    state.caret.block = state.caret.block + 1;
    state.caret.offset = 0;
    state.sel = null;
  }

  function backspace(){
    if(state.sel){ deleteSelection(); return; }
    const p = state.doc[state.caret.block];
    if(state.caret.offset > 0){
      pushUndo();
      // remove char before caret across runs
      const newText = removeRangeFromParagraph(p, state.caret.offset-1, state.caret.offset);
      p.blocks = [{ text: newText, style: Object.assign({}, p.blocks[0].style) }];
      state.caret.offset -= 1;
    } else if(state.caret.block > 0){
      pushUndo();
      const prev = state.doc[state.caret.block-1];
      const merged = paragraphText(prev) + paragraphText(p);
      prev.blocks = [{ text: merged, style: Object.assign({}, prev.blocks[0].style) }];
      state.doc.splice(state.caret.block,1);
      state.caret.block -= 1;
      state.caret.offset = paragraphLength(prev) - paragraphLength(p);
    }
  }

  function deleteForward(){
    if(state.sel){ deleteSelection(); return; }
    const p = state.doc[state.caret.block];
    if(state.caret.offset < paragraphLength(p)){
      pushUndo();
      const newText = removeRangeFromParagraph(p, state.caret.offset, state.caret.offset+1);
      p.blocks = [{ text: newText, style: Object.assign({}, p.blocks[0].style) }];
    } else if(state.caret.block < state.doc.length - 1){
      pushUndo();
      const next = state.doc[state.caret.block+1];
      p.blocks = [{ text: paragraphText(p) + paragraphText(next), style: Object.assign({}, p.blocks[0].style) }];
      state.doc.splice(state.caret.block+1,1);
    }
  }

  function moveCaretLeft(mod){
    if(state.sel && !mod){ const n = normalizeSel(); state.caret = { block: n.start.block, offset: n.start.offset }; state.sel = null; return; }
    if(state.caret.offset > 0) state.caret.offset--; else if(state.caret.block > 0){ state.caret.block--; state.caret.offset = paragraphLength(state.doc[state.caret.block]); }
    if(!mod) state.sel = null;
  }
  function moveCaretRight(mod){
    if(state.sel && !mod){ const n = normalizeSel(); state.caret = { block: n.end.block, offset: n.end.offset }; state.sel = null; return; }
    if(state.caret.offset < paragraphLength(state.doc[state.caret.block])) state.caret.offset++; else if(state.caret.block < state.doc.length-1){ state.caret.block++; state.caret.offset = 0; }
    if(!mod) state.sel = null;
  }

  function applyStyleToRange(style){
    if(!state.sel){
      Object.assign(state.tool, style);
      return;
    }
    pushUndo();
    const norm = normalizeSel();
    const {start,end} = norm;
    if(start.block === end.block){
      const p = state.doc[start.block];
      const before = substringParagraph(p, 0, start.offset);
      const mid = substringParagraph(p, start.offset, end.offset);
      const after = substringParagraph(p, end.offset, paragraphLength(p));
      const baseStyle = p.blocks[0].style;
      const leftStyle = Object.assign({}, baseStyle);
      const midStyle = Object.assign({}, baseStyle, style);
      const rightStyle = Object.assign({}, baseStyle);
      const runs = [];
      if(before.length) runs.push({ text: before, style: leftStyle });
      if(mid.length) runs.push({ text: mid, style: midStyle });
      if(after.length) runs.push({ text: after, style: rightStyle });
      p.blocks = runs.length ? runs : [{ text:'', style: baseStyle }];
      state.sel = null;
      state.caret = { block: start.block, offset: start.offset + (mid.length) };
    } else {
      // apply to start..end paragraphs simplification: apply whole-part style
      for(let b = start.block; b <= end.block; b++){
        const p = state.doc[b];
        if(b === start.block){
          const before = substringParagraph(p, 0, start.offset);
          const after = substringParagraph(p, start.offset, paragraphLength(p));
          const baseStyle = p.blocks[0].style;
          const left = before.length ? { text: before, style: Object.assign({}, baseStyle) } : null;
          const mid = after.length ? { text: after, style: Object.assign({}, baseStyle, style) } : null;
          const runs = [];
          if(left) runs.push(left);
          if(mid) runs.push(mid);
          p.blocks = runs.length ? runs : [{ text:'', style: baseStyle }];
        } else if(b === end.block){
          const before = substringParagraph(p, 0, end.offset);
          const after = substringParagraph(p, end.offset, paragraphLength(p));
          const baseStyle = p.blocks[0].style;
          const left = before.length ? { text: before, style: Object.assign({}, baseStyle, style) } : null;
          const right = after.length ? { text: after, style: Object.assign({}, baseStyle) } : null;
          const runs = [];
          if(left) runs.push(left);
          if(right) runs.push(right);
          p.blocks = runs.length ? runs : [{ text:'', style: baseStyle }];
        } else {
          p.blocks = [{ text: paragraphText(p), style: Object.assign({}, p.blocks[0].style, style) }];
        }
      }
      state.sel = null;
      state.caret = { block: start.block, offset: start.offset };
    }
  }

  function paragraphText(p){ return p.blocks.map(r=>r.text).join(''); }
  function paragraphLength(p){ return paragraphText(p).length; }
  function substringParagraph(p, from, to){
    // returns substring between character offsets (across runs)
    let acc = 0; let res = '';
    for(const r of p.blocks){
      const rt = r.text;
      if(acc + rt.length <= from){ acc += rt.length; continue; }
      const localFrom = Math.max(0, from - acc);
      const localTo = Math.max(0, Math.min(rt.length, to - acc));
      if(localTo > localFrom) res += rt.slice(localFrom, localTo);
      acc += rt.length;
      if(acc >= to) break;
    }
    return res;
  }
  function removeRangeFromParagraph(p, from, to){
    const before = substringParagraph(p, 0, from);
    const after = substringParagraph(p, to, paragraphLength(p));
    return before + after;
  }
  function findRunIndexAtOffset(p, offset){
    let acc = 0;
    for(let i=0;i<p.blocks.length;i++){
      const len = p.blocks[i].text.length;
      if(offset <= acc + len) return { runIndex:i, runOffset: offset - acc };
      acc += len;
    }
    return { runIndex: p.blocks.length-1, runOffset: p.blocks[p.blocks.length-1].text.length };
  }

  ime.addEventListener('input', (e)=>{
    if(state.composing) return;
    const val = ime.value;
    if(val.length>0){ insertTextAtCaret(val); ime.value=''; render(); }
  });
  ime.addEventListener('compositionstart', ()=>{ state.composing = true; });
  ime.addEventListener('compositionupdate', (e)=>{ render(); });
  ime.addEventListener('compositionend', (e)=>{ state.composing=false; const val = e.data || ime.value; if(val){ insertTextAtCaret(val); ime.value=''; render(); } });

  canvas.addEventListener('mousedown', (e)=>{
    const rect = canvas.getBoundingClientRect();
    const startX = e.clientX - rect.left, startY = e.clientY - rect.top;
    const hit = hitTestCanvasPos(startX, startY);
    state.sel = null;
    state.caret = hit;
    focusIMEAtCanvas(startX, startY);
    render();
    const onmove = (ev)=>{
      const rx = ev.clientX - rect.left, ry = ev.clientY - rect.top;
      const hit2 = hitTestCanvasPos(rx, ry);
      setSelectionRange(state.caret, hit2);
      render();
    };
    const onup = ()=>{ window.removeEventListener('mousemove', onmove); window.removeEventListener('mouseup', onup); };
    window.addEventListener('mousemove', onmove);
    window.addEventListener('mouseup', onup);
  });

  function setSelectionRange(a,b){ state.sel = { start: a, end: b }; }

  function focusIMEAtCanvas(x,y){ ime.style.left = (x+4) + 'px'; ime.style.top = (y+4) + 'px'; ime.focus(); }

  document.addEventListener('keydown', (e)=>{
    const meta = e.ctrlKey || e.metaKey;
    if(meta && e.key.toLowerCase()==='b'){ e.preventDefault(); applyStyleToRange({ bold: !state.tool.bold }); state.tool.bold = !state.tool.bold; render(); return; }
    if(meta && e.key.toLowerCase()==='i'){ e.preventDefault(); applyStyleToRange({ italic: !state.tool.italic }); state.tool.italic = !state.tool.italic; render(); return; }
    if(meta && e.key.toLowerCase()==='u'){ e.preventDefault(); applyStyleToRange({ underline: !state.tool.underline }); state.tool.underline = !state.tool.underline; render(); return; }
    if(meta && e.key.toLowerCase()==='z'){ e.preventDefault(); if(e.shiftKey) redo(); else undo(); return; }
    if(meta && e.key.toLowerCase()==='y'){ e.preventDefault(); redo(); return; }
    if(e.key === 'Enter'){ e.preventDefault(); insertNewline(); render(); return; }
    if(e.key === 'Backspace'){ e.preventDefault(); backspace(); render(); return; }
    if(e.key === 'Delete'){ e.preventDefault(); deleteForward(); render(); return; }
    if(e.key === 'ArrowLeft'){ e.preventDefault(); moveCaretLeft(e.shiftKey); render(); return; }
    if(e.key === 'ArrowRight'){ e.preventDefault(); moveCaretRight(e.shiftKey); render(); return; }
    if(e.key.length === 1 && !meta){ ime.focus(); }
  });

  function undo(){ if(state.undoStack.length===0) return; const s = state.undoStack.pop(); state.redoStack.push(cloneStateForUndo()); restoreFromUndo(s); render(); }
  function redo(){ if(state.redoStack.length===0) return; const s = state.redoStack.pop(); state.undoStack.push(cloneStateForUndo()); restoreFromUndo(s); render(); }

  document.getElementById('btnBold').addEventListener('click', ()=>{ applyStyleToRange({ bold: !state.tool.bold }); state.tool.bold = !state.tool.bold; render(); });
  document.getElementById('btnItalic').addEventListener('click', ()=>{ applyStyleToRange({ italic: !state.tool.italic }); state.tool.italic = !state.tool.italic; render(); });
  document.getElementById('btnUnderline').addEventListener('click', ()=>{ applyStyleToRange({ underline: !state.tool.underline }); state.tool.underline = !state.tool.underline; render(); });
  document.getElementById('fontSize').addEventListener('change', (e)=>{ const v = parseInt(e.target.value,10); state.tool.fontSize=v; applyStyleToRange({ fontSize:v }); render(); });
  document.getElementById('fontColor').addEventListener('change', (e)=>{ const v = e.target.value; state.tool.color=v; applyStyleToRange({ color:v }); render(); });
  document.getElementById('btnLeft').addEventListener('click', ()=>{ state.tool.align='left'; render(); });
  document.getElementById('btnCenter').addEventListener('click', ()=>{ state.tool.align='center'; render(); });
  document.getElementById('btnRight').addEventListener('click', ()=>{ state.tool.align='right'; render(); });
  document.getElementById('btnUndo').addEventListener('click', undo);
  document.getElementById('btnRedo').addEventListener('click', redo);

  function fontString(style){
    const size = (style.fontSize || state.tool.fontSize || 16) + 'px';
    let f = '';
    if(style.italic) f += 'italic ';
    if(style.bold) f += 'bold ';
    f += size + ' sans-serif';
    return f;
  }

  function render(){
    ctx.clearRect(0,0,canvas.width/dpr,canvas.height/dpr);
    ctx.fillStyle = '#fff';
    ctx.fillRect(0,0,canvas.width/dpr,canvas.height/dpr);
    const margin = 8;
    let y = margin;
    for(let i=0;i<state.doc.length;i++){
      const p = state.doc[i];
      // compute total paragraph height as single-line per paragraph for prototype
      let x = margin;
      const lineHeight = (p.blocks[0].style.fontSize || state.tool.fontSize || 16) * 1.3;
      // render runs sequentially
      for(const run of p.blocks){
        const style = run.style;
        ctx.font = fontString(style);
        ctx.textBaseline = 'top';
        ctx.fillStyle = style.color || '#000';
        ctx.fillText(run.text, x, y);
        // underline
        if(style.underline){
          const w = ctx.measureText(run.text).width;
          const fs = style.fontSize || state.tool.fontSize || 16;
          ctx.fillRect(x, y + fs + 2, w, 1);
        }
        x += ctx.measureText(run.text).width;
      }
      // selection background per paragraph (if any)
      if(state.sel && isSelectionInBlock(i, state.sel)){
        drawSelectionBackground(i, margin, y, lineHeight);
      }
      // caret
      if(state.caret.block === i && state.caretVisible){
        const caretX = margin + measureParagraphWidthUpToOffset(p, state.caret.offset);
        const fs = (p.blocks[0].style.fontSize || state.tool.fontSize || 16);
        ctx.fillStyle = '#000';
        ctx.fillRect(caretX, y, 1, fs);
      }
      y += lineHeight;
    }
  }

  function measureParagraphWidthUpToOffset(p, offset){
    // measure runs up to offset
    let acc = 0, w = 0;
    for(const run of p.blocks){
      if(offset <= acc + run.text.length){
        const substr = run.text.slice(0, offset - acc);
        ctx.font = fontString(run.style);
        w += ctx.measureText(substr).width;
        return w;
      } else {
        ctx.font = fontString(run.style);
        w += ctx.measureText(run.text).width;
      }
      acc += run.text.length;
    }
    return w;
  }

  function isSelectionInBlock(blockIndex, sel){
    if(!sel) return false;
    const n = normalizeSel();
    return n.start.block <= blockIndex && n.end.block >= blockIndex;
  }

  function drawSelectionBackground(blockIndex, x, y, lineHeight){
    const n = normalizeSel();
    const p = state.doc[blockIndex];
    ctx.save();
    ctx.fillStyle = 'rgba(100,150,255,0.25)';
    if(n.start.block === n.end.block){
      // same paragraph selection
      const beforeW = measureParagraphWidthUpToOffset(p, n.start.offset);
      const selW = measureParagraphWidthUpToOffset(p, n.end.offset) - beforeW;
      ctx.fillRect(x + beforeW, y, selW, lineHeight);
    } else if(blockIndex === n.start.block){
      const beforeW = measureParagraphWidthUpToOffset(p, n.start.offset);
      const selW = measureParagraphWidthUpToOffset(p, paragraphLength(p)) - beforeW;
      ctx.fillRect(x + beforeW, y, selW, lineHeight);
    } else if(blockIndex === n.end.block){
      const selW = measureParagraphWidthUpToOffset(p, n.end.offset);
      ctx.fillRect(x, y, selW, lineHeight);
    } else {
      const fullW = measureParagraphWidthUpToOffset(p, paragraphLength(p));
      ctx.fillRect(x, y, fullW, lineHeight);
    }
    ctx.restore();
  }

  function hitTestCanvasPos(x,y){
    const margin = 8;
    let cy = margin;
    for(let i=0;i<state.doc.length;i++){
      const p = state.doc[i];
      const fs = p.blocks[0].style.fontSize || state.tool.fontSize || 16;
      const lh = fs * 1.3;
      if(y >= cy && y <= cy + lh){
        // measure across runs
        let acc = 0;
        let rx = margin;
        for(const run of p.blocks){
          ctx.font = fontString(run.style);
          for(let j=0;j<=run.text.length;j++){
            const substr = run.text.slice(0,j);
            const w = ctx.measureText(substr).width;
            if(x < rx + w + 4){
              return { block:i, offset: acc + j };
            }
          }
          rx += ctx.measureText(run.text).width;
          acc += run.text.length;
        }
        return { block:i, offset: paragraphLength(p) };
      }
      cy += (p.blocks[0].style.fontSize || state.tool.fontSize || 16) * 1.3;
    }
    const last = state.doc.length - 1;
    return { block: last, offset: paragraphLength(state.doc[last]) };
  }

  document.addEventListener('paste', (e)=>{
    const text = (e.clipboardData || window.clipboardData).getData('text');
    if(text){ insertTextAtCaret(text); render(); e.preventDefault(); }
  });

  // blinking caret
  setInterval(()=>{ state.caretVisible = !state.caretVisible; render(); }, 500);

  // helpers used above
  function paragraphText(p){ return p.blocks.map(r=>r.text).join(''); }
  function paragraphLength(p){ return paragraphText(p).length; }

  // initial setup
  resize();
  render();
})();
</script>
</body>
</html>
=======
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>


</head>
<body>
    <canvas id="canvas"></canvas>

    <script>
        function Mitt(all=new Map()){
            return {
                on(type, handler) {
                    let handlers = all.get(type);
                    if (!handlers) {
                        handlers = new Set();
                        all.set(type, handlers);
                    }
                    handlers.add(handler);
                },
                off(type, handler) {
                    const handlers = all.get(type);
                    if (handlers) {
                        if(handler){
                            handlers.delete(handler);
                        }else{
                            handlers.clear()
                        }
                    }
                },
                emit(type, ...args) {
                    
                    for (const handler of all.get(type) || []) {
                        handler(...args);
                    }
                    for (const handler of all.get('*') || []) {
                        handler(type, ...args);
                    }
                },
                clear() {
                    all.clear();
                }

            };
        }

       
      
        class RichTextEditor{
            constructor() {
                this.mitt = Mitt();
                Object.assign(this, this.mitt)
            }
            createMeasurementCanvas(){
                if(this.measurementCanvas){
                    return
                }
                const canvas=this.measurementCanvas = document.createElement('canvas')
                this.measurementCtx=canvas.getContext('2d')
                canvas.width=100
                canvas.height=100

            }
            getDefaultOptions(){
                return {

                }
            }
            init(options){
                 this.createMeasurementCanvas()
                this.ctx=options.ctx

                // 当前样式
                this.curStyle={
                    fontSize:16,
                    color:'#000',
                    lineHeight:1.5,
                    fontFamily:'Arial',


                }
                this.blocks=[]
                // 边框信息
                this.border={
                    borderColor:'#000',
                    borderWidth:1,
                    borderStyle:'solid',
                }
                // 编辑基本样式
                this.x=options.x??0
                this.y=options.y??0
                this.width=options.width??this.ctx.canvas.width
                this.height=options.height??'auto'
                this._scrollHeight=0
                this.borderRadius=options.borderRadius??6
                this.borderColor=options.borderColor??'#000'
                this.borderWidth=options.borderWidth??1
                this.borderStyle=options.borderStyle??'solid'
                // 当前选中区域信息
                this.selection={
                    start:0,
                    end:0
                }
                // 当前光标位置信息
                this.cursor={
                    visible:true,
                    offset:0,
                    line:0
                }
                // 文本输入框样式
                const input=document.createElement('input')
                input.style.position='absolute'
                input.style.width='1px'
                input.style.opacity=0
                input.style.pointerEvents='none'
                input.style.zIndex=-1
                document.body.appendChild(input)
                this.input=input
                this.handleEvent=this.handleEvent.bind(this)
                this.attachEvents()
                this.registerCommands()
            }
            registerCommands(){
                    this.on('bold',()=>{
                        
                    })
                    this.on('undo',()=>{

                    })
                    this.on('redo',()=>{

                    })
            }
            executeCommand(command, ...args){
                this.emit(cmmand, ...args)
            }
            handleEvent(e){
               this.emit(e.type,e)
            }
            attachEvents(){
                this.ctx.canvas.addEventListener('mousedown', this)
            }
            detachEvents(){
                this.ctx.canvas.removeEventListener('mousedown', this)
            }

            get computedHeight(){
                if(this.height==='auto'){
                    return this.scrollHeight
                }else{
                    return this.height
                }
            }
            get scrollHeight(){
                return this._scrollHeight||0

            }
            createPragraph(){
                return {
                    type:'pragraph',
                    data:[],
                    style:{
                        ...this.curStyle
                    }
                }
            }
    
            measureCache=new Map()
            measure(text,options={}){
                const ctx=this.measurementCtx
                const {fontSize=16,fontFamily='sans-serif',bold=false,textBaseline='middle'}=options
                const key=JSON.stringify(options)+'_'+text
                if(this.measureCache.has(key)){
                    return this.measureCache.get(key)
                }
                
                ctx.font=`${fontSize}px ${fontFamily}`
                ctx.fontStretchWeight=bold?'bold':'normal'
                ctx.textBaseline='top'
                ctx.textAlign='left'
                ctx.letterSpacing=0 // 字母间距
                ctx.wordSpacing=0 // 单词间距
                const measureInfo=ctx.measureText(text)
                this.measureCache.set(key, measureInfo)
                if(this.measureCache.size>20){
                    this.measureCache.delete(this.measureCache.keys().next().value)
                }
                return measureInfo
            }
            getFontHeight(text,options={}){
                const measureInfo=this.measure(text, options)
                return measureInfo.fontBoundingBoxAscent+measureInfo.fontBoundingBoxDescent
            }
            getPragraphInfo(pragraph){
                 if(pragraph.data.length<=0){
                    return pragraph.style.lineHeight*pragraph.style.fontSize
                 }
                 let maxHeight=0
                 let width=0
                 let lines=[]
                 let text=''
                 pragraph.data.forEach((d)=>{
                        const measureInfo=this.measure(d.text, d.style||pragraph.style)
                        const height= measureInfo.fontBoundingBoxAscent+measureInfo.fontBoundingBoxDescent
                        width+=measureInfo.width
                        maxHeight=Math.max(maxHeight,height)
                        text
                        
                })
                if(width>0){
                    lines.push({
                        text,
                        width,
                        height:maxHeight
                    })
                }
                return lines[0]
            }

            updateEditState(){
                this.lines=[]
                let lastY=0
                let height=0
                let scrollHeight=0
                this.blocks.forEach((block,i)=>{
                    const texts=this.getPragraphInfo(block)
                    block.width=info.width
                    block.height=info.height
                    lines.push({width:info.width,y0:lastY, y2:info.height+lastY,blockIndex:i})
                    lastY+=info.height
                    scrollHeight+=info.height
                    this.lines.push(lines)
                })
                this._scrollHeight=scrollHeight
            }
            // 绘制边框
            renderBorder(ctx){
                ctx.save()
                ctx.beginPath()
                ctx.strokeStyle=this.borderColor
                ctx.lineWidth=this.borderWidth
                if(this.borderRadius>0){
                    ctx.roundRect(this.x, this.y, this.width, this.computedHeight, this.borderRadius)
                }else{
                    ctx.rect(this.x, this.y, this.width, this.computedHeight)
                }
                ctx.stroke()
                ctx.restore()

            }
            renderCursor(ctx){
              
                if(!this.cursor.visible){
                    return
                }

                ctx.save()
                ctx.beginPath()
                ctx.strokeStyle=this.borderColor
                ctx.lineWidth=1
                ctx.restore()

            }
            render(){
                this.renderBorder(this.ctx)
            }
        }
        

        function init(){
            var canvas = document.getElementById('canvas');
            canvas.width=500
            canvas.height=500
            var ctx = canvas.getContext('2d');

            const rich=new RichTextEditor()
            rich.init({
                ctx:ctx
            })
            rich.render()

        }
        init()

    </script>
</body>
</html>
>>>>>>> 7f6717411deae413eb610c9b4ea43c133a18dbe8
