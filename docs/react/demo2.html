<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div id="root"></div>
    <script>
        /*
A compact, educational React-like library implementing core ideas from React 19.x:
- createElement / JSX-friendly
- Fiber reconciliation (beginWork / completeWork / commitWork)
- Scheduler (simple priority lanes + requestIdleCallback fallback)
- Function components + Hooks: useState, useReducer, useRef, useMemo, useCallback, useEffect, useLayoutEffect, useContext, useImperativeHandle, useTransition
- Error boundaries via simple class components

This is intentionally simplified for clarity, not production-ready.
*/

        // --- Element / createElement ---
        function createElement(type, props, ...children) {
            return {
                type,
                props: Object.assign({}, props, {
                    children: children.flat().map(c => typeof c === 'object' ? c : createTextElement(c))
                })
            };
        }
        function createTextElement(text) {
            return { type: 'TEXT_ELEMENT', props: { nodeValue: text, children: [] } };
        }

        // --- Host utilities ---
        function createDom(fiber) {
            const dom = fiber.type === 'TEXT_ELEMENT' ? document.createTextNode('') : document.createElement(fiber.type);
            updateDom(dom, {}, fiber.props);
            return dom;
        }

        const isEvent = key => key.startsWith('on');
        const isProperty = key => key !== 'children' && !isEvent(key);
        function updateDom(dom, prevProps, nextProps) {
            // remove old events
            Object.keys(prevProps).filter(isEvent).forEach(name => {
                const eventType = name.toLowerCase().substring(2);
                dom.removeEventListener(eventType, prevProps[name]);
            });
            // remove old properties
            Object.keys(prevProps).filter(isProperty).forEach(name => {
                if (!(name in nextProps)) dom[name] = '';
            });
            // set new properties
            Object.keys(nextProps).filter(isProperty).forEach(name => {
                dom[name] = nextProps[name];
            });
            // add events
            Object.keys(nextProps).filter(isEvent).forEach(name => {
                const eventType = name.toLowerCase().substring(2);
                dom.addEventListener(eventType, nextProps[name]);
            });
        }

        // --- Fiber tree and scheduler ---
        let nextUnitOfWork = null;
        let wipRoot = null;
        let currentRoot = null;
        let deletions = null;
        let wipFiber = null; // for hooks
        let hookIndex = null;

        // Simple lanes/priority system
        const Lane = { Sync: 1, Transition: 2, Idle: 4 };
        let currentPriority = Lane.Sync;

        function scheduleRoot(rootFiber, priority = Lane.Sync) {
            currentPriority = priority;
            wipRoot = rootFiber;
            nextUnitOfWork = wipRoot;
            deletions = [];
            requestWorkLoop();
        }

        function requestWorkLoop() {
            if (typeof requestIdleCallback !== 'undefined') {
                requestIdleCallback(workLoop);
            } else {
                setTimeout(() => workLoop({ timeRemaining: () => 50 }), 1);
            }
        }

        function workLoop(deadline) {
            let shouldYield = false;
            while (nextUnitOfWork && !shouldYield) {
                nextUnitOfWork = performUnitOfWork(nextUnitOfWork);
                shouldYield = deadline.timeRemaining() < 1;
            }
            if (!nextUnitOfWork && wipRoot) {
                commitRoot();
            } else if (nextUnitOfWork) {
                requestWorkLoop();
            }
        }

        function performUnitOfWork(fiber) {
            const isFunctionComponent = typeof fiber.type === 'function';
            if (isFunctionComponent) {
                updateFunctionComponent(fiber);
            } else {
                updateHostComponent(fiber);
            }
            if (fiber.child) return fiber.child;
            let next = fiber;
            while (next) {
                if (next.sibling) return next.sibling;
                next = next.parent;
            }
            return null;
        }

        function updateFunctionComponent(fiber) {
            wipFiber = fiber;
            hookIndex = 0;
            wipFiber.hooks = [];
            try {
                const children = [fiber.type(fiber.props)];
                reconcileChildren(fiber, children);
            } catch (err) {
                captureError(fiber, err);
            }
        }

        function updateHostComponent(fiber) {
            if (!fiber.dom) fiber.dom = createDom(fiber);
            reconcileChildren(fiber, fiber.props.children);
        }

        function reconcileChildren(wipFiberNode, elements) {
            let index = 0;
            let oldFiber = wipFiberNode.alternate && wipFiberNode.alternate.child;
            let prevSibling = null;
            while (index < elements.length || oldFiber) {
                const element = elements[index];
                let newFiber = null;
                const sameType = oldFiber && element && element.type === oldFiber.type;
                if (sameType) {
                    newFiber = {
                        type: oldFiber.type,
                        props: element.props,
                        dom: oldFiber.dom,
                        parent: wipFiberNode,
                        alternate: oldFiber,
                        effectTag: 'UPDATE'
                    };
                }
                if (element && !sameType) {
                    newFiber = {
                        type: element.type,
                        props: element.props,
                        dom: null,
                        parent: wipFiberNode,
                        alternate: null,
                        effectTag: 'PLACEMENT'
                    };
                }
                if (oldFiber && !sameType) {
                    oldFiber.effectTag = 'DELETION';
                    deletions.push(oldFiber);
                }
                if (oldFiber) oldFiber = oldFiber.sibling;
                if (index === 0) wipFiberNode.child = newFiber;
                else if (element) prevSibling.sibling = newFiber;
                prevSibling = newFiber;
                index++;
            }
        }

        // --- Commit phase ---
        function commitRoot() {
            deletions.forEach(commitWork);
            commitWork(wipRoot.child);
            currentRoot = wipRoot;
            wipRoot = null;
        }

        function commitWork(fiber) {
            if (!fiber) return;
            let domParentFiber = fiber.parent;
            while (!domParentFiber.dom) domParentFiber = domParentFiber.parent;
            const parentDom = domParentFiber.dom;
            if (fiber.effectTag === 'PLACEMENT' && fiber.dom != null) {
                parentDom.appendChild(fiber.dom);
            } else if (fiber.effectTag === 'DELETION') {
                commitDeletion(fiber, parentDom);
            } else if (fiber.effectTag === 'UPDATE' && fiber.dom != null) {
                updateDom(fiber.dom, fiber.alternate.props, fiber.props);
            }
            commitWork(fiber.child);
            commitWork(fiber.sibling);
        }

        function commitDeletion(fiber, parentDom) {
            if (fiber.dom) parentDom.removeChild(fiber.dom);
            else commitDeletion(fiber.child, parentDom);
        }

        // --- Public render API ---
        function render(element, container) {
            wipRoot = {
                dom: container,
                props: { children: [element] },
                alternate: currentRoot
            };
            scheduleRoot(wipRoot, Lane.Sync);
        }

        // --- Hooks ---
        function useState(initial) {
            const oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];
            const hook = {
                state: oldHook ? oldHook.state : typeof initial === 'function' ? initial() : initial,
                queue: []
            };
            const actions = oldHook ? oldHook.queue : [];
            actions.forEach(action => {
                hook.state = typeof action === 'function' ? action(hook.state) : action;
            });
            const setState = action => {
                hook.queue.push(action);
                // schedule an update
                wipRoot = {
                    dom: currentRoot.dom,
                    props: currentRoot.props,
                    alternate: currentRoot
                };
                scheduleRoot(wipRoot, Lane.Sync);
            };
            wipFiber.hooks.push(hook);
            hookIndex++;
            return [hook.state, setState];
        }

        function useReducer(reducer, initial, init) {
            const [state, setState] = useState(() => (init ? init(initial) : initial));
            function dispatch(action) {
                setState(prev => reducer(prev, action));
            }
            return [state, dispatch];
        }

        function useRef(initial) {
            const oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];
            const hook = { current: oldHook ? oldHook.current : initial };
            wipFiber.hooks.push(hook);
            hookIndex++;
            return hook;
        }

        function useCallback(fn, deps) {
            return useMemo(() => fn, deps);
        }

        function useMemo(factory, deps) {
            const oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];
            const hook = { value: null, deps: null };
            if (oldHook && deps && oldHook.deps && deps.length === oldHook.deps.length && deps.every((d, i) => d === oldHook.deps[i])) {
                hook.value = oldHook.value;
                hook.deps = oldHook.deps;
            } else {
                hook.value = factory();
                hook.deps = deps;
            }
            wipFiber.hooks.push(hook);
            hookIndex++;
            return hook.value;
        }

        // Simplified Context
        function createContext(defaultValue) {
            const context = { _currentValue: defaultValue };
            function Provider(props) {
                context._currentValue = props.value;
                return props.children[0];
            }
            context.Provider = Provider;
            return context;
        }

        function useContext(context) {
            return context._currentValue;
        }

        // Effects: we collect effects on fibers and run after commit
        function useEffect(effect, deps) {
            useEffectImpl(effect, deps, false);
        }
        function useLayoutEffect(effect, deps) {
            useEffectImpl(effect, deps, true);
        }

        function useEffectImpl(effect, deps, isLayout) {
            const oldHook = wipFiber.alternate && wipFiber.alternate.hooks && wipFiber.alternate.hooks[hookIndex];
            const hook = { deps: null, cleanup: null };
            let hasChanged = true;
            if (oldHook) {
                if (deps && oldHook.deps && deps.length === oldHook.deps.length && deps.every((d, i) => d === oldHook.deps[i])) {
                    hasChanged = false;
                }
            }
            if (hasChanged) {
                hook.deps = deps;
                hook.effect = effect;
                // register a post-commit runner on the fiber
                wipFiber.effects = wipFiber.effects || [];
                wipFiber.effects.push({ hookIndex, effect, isLayout, oldHook });
            } else {
                hook.deps = oldHook.deps;
                hook.cleanup = oldHook.cleanup;
            }
            wipFiber.hooks.push(hook);
            hookIndex++;
        }

        // After commit, run effects
        function runEffects(fiber) {
            if (!fiber) return;
            // run layout effects first
            if (fiber.effects) {
                fiber.effects.filter(e => e.isLayout).forEach(e => {
                    try {
                        if (e.oldHook && e.oldHook.cleanup) e.oldHook.cleanup();
                        const cleanup = e.effect();
                        const hook = fiber.hooks[e.hookIndex];
                        if (hook) hook.cleanup = cleanup;
                    } catch (err) {
                        captureError(fiber, err);
                    }
                });
            }
            // standard effects queued via setTimeout to run after painting
            if (fiber.effects) {
                fiber.effects.filter(e => !e.isLayout).forEach(e => {
                    setTimeout(() => {
                        try {
                            if (e.oldHook && e.oldHook.cleanup) e.oldHook.cleanup();
                            e.effect();
                        } catch (err) {
                            captureError(fiber, err);
                        }
                    }, 0);
                });
            }
            runEffects(fiber.child);
            runEffects(fiber.sibling);
        }

        // Call runEffects after commitRoot
        const originalCommitRoot = commitRoot;
        commitRoot = function () {
            deletions.forEach(commitWork);
            commitWork(wipRoot.child);
            currentRoot = wipRoot;
            wipRoot = null;
            // run effects on committed tree
            runEffects(currentRoot.child);
        };

        // --- Error handling (very simplified) ---
        function captureError(fiber, error) {
            // climb up to find nearest error boundary (class with componentDidCatch)
            let boundary = fiber.parent;
            while (boundary) {
                if (boundary.type && boundary.type.prototype && typeof boundary.type.prototype.componentDidCatch === 'function') break;
                boundary = boundary.parent;
            }
            if (boundary) {
                try {
                    boundary.type.prototype.componentDidCatch.call(boundary.stateNode || {}, error);
                    // re-render boundary subtree
                    wipRoot = {
                        dom: currentRoot.dom,
                        props: currentRoot.props,
                        alternate: currentRoot
                    };
                    scheduleRoot(wipRoot, Lane.Sync);
                } catch (err) {
                    console.error('Error boundary failed', err);
                }
            } else {
                console.error('Uncaught in render:', error);
                throw error;
            }
        }

        // --- Imperative handle stub ---
        function useImperativeHandle(ref, create, deps) {
            const val = useMemo(() => create(), deps);
            if (ref) ref.current = val;
        }

        // --- Transition ---
        let pendingTransitions = 0;
        function startTransition(fn) {
            pendingTransitions++;
            const prev = currentPriority;
            currentPriority = Lane.Transition;
            try {
                fn();
            } finally {
                currentPriority = prev;
                pendingTransitions--;
            }
        }

        function useTransition() {
            const [isPending, setPending] = useState(false);
            function start(fn) {
                setPending(true);
                startTransition(() => {
                    fn();
                    setPending(false);
                });
            }
            return [isPending, start];
        }

        // --- Exports ---
        const MiniReact = {
            createElement,
            render,
            useState,
            useReducer,
            useRef,
            useMemo,
            useCallback,
            useEffect,
            useLayoutEffect,
            createContext,
            useContext,
            useImperativeHandle,
            startTransition,
            useTransition
        };

        const h=createElement
        function App() {
            const [n, setN] = useState(0);
            return h('div', null, h('h1', null, 'Count: ' + n), h('button', { onClick: () => setN(c => c + 1) }, 'Inc'));
        }

        render(h(App, null), document.getElementById('root'));


    </script>
</body>
</html>