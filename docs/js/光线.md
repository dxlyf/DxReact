<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>光线技术演示</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a2e;
            color: #e6e6e6;
        }
        h1 {
            text-align: center;
            color: #4cc9f0;
            margin-bottom: 30px;
        }
        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }
        .technique {
            background-color: #16213e;
            border-radius: 10px;
            padding: 15px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        h2 {
            color: #4cc9f0;
            border-bottom: 1px solid #4cc9f0;
            padding-bottom: 8px;
        }
        .description {
            margin-bottom: 15px;
            line-height: 1.5;
        }
        canvas {
            width: 100%;
            height: 300px;
            background-color: #0f3460;
            border-radius: 5px;
            display: block;
        }
        .controls {
            margin-top: 10px;
            display: flex;
            justify-content: space-between;
        }
        button {
            background-color: #4cc9f0;
            color: #1a1a2e;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #3aa8d0;
        }
        .info {
            font-size: 0.9em;
            color: #a5b1c2;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <h1>光线追踪技术演示</h1>
    
    <div class="container">
        <!-- 光线投射 -->
        <div class="technique">
            <h2>光线投射 (Ray Casting)</h2>
            <div class="description">
                从相机发射光线到场景中，找到最近的交点。常用于早期3D游戏如《Wolfenstein 3D》。
            </div>
            <canvas id="rayCastingCanvas"></canvas>
            <div class="controls">
                <button id="rayCastingToggle">暂停/继续</button>
                <div class="info">模拟简单的3D场景渲染</div>
            </div>
        </div>
        
        <!-- 光线步进 -->
        <div class="technique">
            <h2>光线步进 (Ray Marching)</h2>
            <div class="description">
                逐步沿光线方向前进，使用距离函数确定步长。适合渲染复杂几何形状和分形。
            </div>
            <canvas id="rayMarchingCanvas"></canvas>
            <div class="controls">
                <button id="rayMarchingToggle">暂停/继续</button>
                <div class="info">使用球体追踪算法渲染球体</div>
            </div>
        </div>
        
        <!-- 光线追踪 -->
        <div class="technique">
            <h2>光线追踪 (Ray Tracing)</h2>
            <div class="description">
                模拟光线在场景中的反射和折射，产生更真实的光照效果。
            </div>
            <canvas id="rayTracingCanvas"></canvas>
            <div class="controls">
                <button id="rayTracingToggle">暂停/继续</button>
                <div class="info">模拟镜面反射效果</div>
            </div>
        </div>
        
        <!-- 路径追踪 -->
        <div class="technique">
            <h2>路径追踪 (Path Tracing)</h2>
            <div class="description">
                使用蒙特卡洛方法模拟光线在场景中的多次反射，实现全局光照。
            </div>
            <canvas id="pathTracingCanvas"></canvas>
            <div class="controls">
                <button id="pathTracingToggle">暂停/继续</button>
                <div class="info">模拟漫反射和间接光照</div>
            </div>
        </div>
    </div>

    <script>
        // 光线投射示例
        const rayCastingCanvas = document.getElementById('rayCastingCanvas');
        const rayCastingCtx = rayCastingCanvas.getContext('2d');
        rayCastingCanvas.width = rayCastingCanvas.clientWidth;
        rayCastingCanvas.height = rayCastingCanvas.clientHeight;

        let rayCastingRunning = true;
        document.getElementById('rayCastingToggle').addEventListener('click', () => {
            rayCastingRunning = !rayCastingRunning;
            if (rayCastingRunning) {
                animateRayCasting();
            }
        });

        function animateRayCasting() {
            if (!rayCastingRunning) return;
            
            const width = rayCastingCanvas.width;
            const height = rayCastingCanvas.height;
            
            // 清除画布
            rayCastingCtx.fillStyle = '#0f3460';
            rayCastingCtx.fillRect(0, 0, width, height);
            
            // 绘制简单的3D场景
            const time = Date.now() * 0.001;
            const playerX = Math.sin(time) * 0.5;
            
            // 简单的光线投射实现
            for (let x = 0; x < width; x += 2) {
                // 计算光线方向
                const cameraX = 2 * x / width - 1;
                const rayDirX = playerX + cameraX;
                const rayDirY = 1.0;
                
                // 计算与墙壁的交点
                let wallX;
                if (Math.abs(rayDirX) < 0.0001) {
                    wallX = 1000; // 非常远的距离
                } else {
                    wallX = Math.abs(1.0 / rayDirX);
                }
                
                // 根据距离计算墙的高度
                const lineHeight = Math.min(height, height / wallX);
                
                // 绘制垂直线
                const drawStart = Math.max(0, (height - lineHeight) / 2);
                const drawEnd = Math.min(height, (height + lineHeight) / 2);
                
                // 根据距离选择颜色
                let color;
                if (wallX < 5) color = '#ff6b6b';
                else if (wallX < 10) color = '#4ecdc4';
                else if (wallX < 15) color = '#45b7d1';
                else color = '#96ceb4';
                
                rayCastingCtx.fillStyle = color;
                rayCastingCtx.fillRect(x, drawStart, 2, drawEnd - drawStart);
                
                // 绘制地板和天花板
                rayCastingCtx.fillStyle = '#4a4a4a';
                rayCastingCtx.fillRect(x, 0, 2, drawStart);
                rayCastingCtx.fillStyle = '#8a8a8a';
                rayCastingCtx.fillRect(x, drawEnd, 2, height - drawEnd);
            }
            
            requestAnimationFrame(animateRayCasting);
        }
        animateRayCasting();

        // 光线步进示例
        const rayMarchingCanvas = document.getElementById('rayMarchingCanvas');
        const rayMarchingCtx = rayMarchingCanvas.getContext('2d');
        rayMarchingCanvas.width = rayMarchingCanvas.clientWidth;
        rayMarchingCanvas.height = rayMarchingCanvas.clientHeight;

        let rayMarchingRunning = true;
        document.getElementById('rayMarchingToggle').addEventListener('click', () => {
            rayMarchingRunning = !rayMarchingRunning;
            if (rayMarchingRunning) {
                animateRayMarching();
            }
        });

        // 球体的距离函数
        function sphereDistance(x, y, z, centerX, centerY, centerZ, radius) {
            return Math.sqrt(
                (x - centerX) * (x - centerX) + 
                (y - centerY) * (y - centerY) + 
                (z - centerZ) * (z - centerZ)
            ) - radius;
        }

        function animateRayMarching() {
            if (!rayMarchingRunning) return;
            
            const width = rayMarchingCanvas.width;
            const height = rayMarchingCanvas.height;
            const imageData = rayMarchingCtx.createImageData(width, height);
            const data = imageData.data;
            
            const time = Date.now() * 0.001;
            
            // 球体参数
            const sphereX = Math.sin(time) * 0.5;
            const sphereY = Math.cos(time * 0.7) * 0.3;
            const sphereZ = 3.0;
            const sphereRadius = 1.0;
            
            // 光线步进参数
            const maxSteps = 100;
            const maxDistance = 20.0;
            const epsilon = 0.001;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // 标准化像素坐标
                    const uvX = (x / width) * 2.0 - 1.0;
                    const uvY = (y / height) * 2.0 - 1.0;
                    
                    // 光线方向
                    const rayDirX = uvX;
                    const rayDirY = uvY;
                    const rayDirZ = 1.0;
                    
                    // 归一化光线方向
                    const length = Math.sqrt(rayDirX * rayDirX + rayDirY * rayDirY + rayDirZ * rayDirZ);
                    const normX = rayDirX / length;
                    const normY = rayDirY / length;
                    const normZ = rayDirZ / length;
                    
                    // 光线步进
                    let totalDistance = 0.0;
                    let hit = false;
                    
                    for (let step = 0; step < maxSteps; step++) {
                        // 当前点位置
                        const pointX = normX * totalDistance;
                        const pointY = normY * totalDistance;
                        const pointZ = normZ * totalDistance;
                        
                        // 计算到球体的距离
                        const distance = sphereDistance(
                            pointX, pointY, pointZ,
                            sphereX, sphereY, sphereZ,
                            sphereRadius
                        );
                        
                        // 如果距离非常小，我们认为击中了物体
                        if (distance < epsilon) {
                            hit = true;
                            break;
                        }
                        
                        // 增加距离
                        totalDistance += distance;
                        
                        // 如果距离太远，停止追踪
                        if (totalDistance > maxDistance) {
                            break;
                        }
                    }
                    
                    // 计算像素索引
                    const pixelIndex = (y * width + x) * 4;
                    
                    if (hit) {
                        // 击中球体，根据距离着色
                        const intensity = 1.0 - (totalDistance / maxDistance);
                        data[pixelIndex] = Math.floor(100 * intensity);     // R
                        data[pixelIndex + 1] = Math.floor(150 * intensity); // G
                        data[pixelIndex + 2] = Math.floor(255 * intensity); // B
                        data[pixelIndex + 3] = 255; // A
                    } else {
                        // 背景色
                        data[pixelIndex] = 30;     // R
                        data[pixelIndex + 1] = 30; // G
                        data[pixelIndex + 2] = 40; // B
                        data[pixelIndex + 3] = 255; // A
                    }
                }
            }
            
            rayMarchingCtx.putImageData(imageData, 0, 0);
            requestAnimationFrame(animateRayMarching);
        }
        animateRayMarching();

        // 光线追踪示例
        const rayTracingCanvas = document.getElementById('rayTracingCanvas');
        const rayTracingCtx = rayTracingCanvas.getContext('2d');
        rayTracingCanvas.width = rayTracingCanvas.clientWidth;
        rayTracingCanvas.height = rayTracingCanvas.clientHeight;

        let rayTracingRunning = true;
        document.getElementById('rayTracingToggle').addEventListener('click', () => {
            rayTracingRunning = !rayTracingRunning;
            if (rayTracingRunning) {
                animateRayTracing();
            }
        });

        function animateRayTracing() {
            if (!rayTracingRunning) return;
            
            const width = rayTracingCanvas.width;
            const height = rayTracingCanvas.height;
            
            // 清除画布
            rayTracingCtx.fillStyle = '#0f3460';
            rayTracingCtx.fillRect(0, 0, width, height);
            
            const time = Date.now() * 0.001;
            
            // 绘制反射场景
            // 主球体
            const centerX = width / 2;
            const centerY = height / 2;
            const radius = 80;
            
            // 创建径向渐变模拟球体
            const gradient = rayTracingCtx.createRadialGradient(
                centerX - 30, centerY - 30, 10,
                centerX, centerY, radius
            );
            gradient.addColorStop(0, '#4cc9f0');
            gradient.addColorStop(1, '#1e3a8a');
            
            rayTracingCtx.fillStyle = gradient;
            rayTracingCtx.beginPath();
            rayTracingCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            rayTracingCtx.fill();
            
            // 添加高光模拟反射
            rayTracingCtx.fillStyle = 'rgba(255, 255, 255, 0.6)';
            rayTracingCtx.beginPath();
            rayTracingCtx.arc(centerX - 30, centerY - 30, 20, 0, Math.PI * 2);
            rayTracingCtx.fill();
            
            // 绘制反射内容
            rayTracingCtx.save();
            rayTracingCtx.globalCompositeOperation = 'source-atop';
            
            // 模拟反射的环境
            rayTracingCtx.fillStyle = '#f72585';
            rayTracingCtx.beginPath();
            rayTracingCtx.arc(centerX + 60 + Math.sin(time) * 20, centerY - 40, 15, 0, Math.PI * 2);
            rayTracingCtx.fill();
            
            rayTracingCtx.fillStyle = '#7209b7';
            rayTracingCtx.beginPath();
            rayTracingCtx.arc(centerX - 70 + Math.cos(time) * 25, centerY + 50, 20, 0, Math.PI * 2);
            rayTracingCtx.fill();
            
            rayTracingCtx.restore();
            
            // 绘制地板反射
            rayTracingCtx.fillStyle = 'rgba(100, 100, 150, 0.3)';
            rayTracingCtx.fillRect(0, centerY + radius, width, height - (centerY + radius));
            
            // 绘制反射的球体
            rayTracingCtx.save();
            rayTracingCtx.globalAlpha = 0.4;
            rayTracingCtx.scale(1, -1);
            rayTracingCtx.translate(0, -height * 2);
            
            const reflectionGradient = rayTracingCtx.createRadialGradient(
                centerX - 20, centerY - 20, 5,
                centerX, centerY, radius
            );
            reflectionGradient.addColorStop(0, '#4cc9f0');
            reflectionGradient.addColorStop(1, '#1e3a8a');
            
            rayTracingCtx.fillStyle = reflectionGradient;
            rayTracingCtx.beginPath();
            rayTracingCtx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            rayTracingCtx.fill();
            
            rayTracingCtx.restore();
            
            requestAnimationFrame(animateRayTracing);
        }
        animateRayTracing();

        // 路径追踪示例
        const pathTracingCanvas = document.getElementById('pathTracingCanvas');
        const pathTracingCtx = pathTracingCanvas.getContext('2d');
        pathTracingCanvas.width = pathTracingCanvas.clientWidth;
        pathTracingCanvas.height = pathTracingCanvas.clientHeight;

        let pathTracingRunning = true;
        document.getElementById('pathTracingToggle').addEventListener('click', () => {
            pathTracingRunning = !pathTracingRunning;
            if (pathTracingRunning) {
                animatePathTracing();
            }
        });

        // 路径追踪的采样数据
        let pathTracingSamples = 0;
        let pathTracingAccumulator = null;

        function initPathTracing() {
            const width = pathTracingCanvas.width;
            const height = pathTracingCanvas.height;
            pathTracingAccumulator = new Array(width * height * 3).fill(0);
        }

        function animatePathTracing() {
            if (!pathTracingRunning) return;
            
            const width = pathTracingCanvas.width;
            const height = pathTracingCanvas.height;
            
            if (!pathTracingAccumulator) {
                initPathTracing();
            }
            
            const imageData = pathTracingCtx.createImageData(width, height);
            const data = imageData.data;
            
            const time = Date.now() * 0.001;
            
            // 模拟路径追踪的渐进渲染
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    // 添加随机噪声模拟路径追踪
                    const noise = (Math.random() - 0.5) * 0.1;
                    
                    // 计算基础颜色
                    let r, g, b;
                    
                    // 球体位置
                    const sphereX = width / 2 + Math.sin(time) * 50;
                    const sphereY = height / 2 + Math.cos(time * 0.7) * 30;
                    const sphereRadius = 60;
                    
                    // 检查是否在球体内
                    const dx = x - sphereX;
                    const dy = y - sphereY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance < sphereRadius) {
                        // 球体颜色 - 模拟漫反射
                        const intensity = 0.7 + 0.3 * Math.sin(time + x * 0.01);
                        r = Math.floor(100 * intensity + 50 * noise);
                        g = Math.floor(180 * intensity + 50 * noise);
                        b = Math.floor(255 * intensity + 50 * noise);
                    } else {
                        // 背景色 - 模拟间接光照
                        const intensity = 0.1 + 0.05 * Math.sin(time * 0.5 + x * 0.005 + y * 0.005);
                        r = Math.floor(30 * intensity + 20 * noise);
                        g = Math.floor(40 * intensity + 20 * noise);
                        b = Math.floor(60 * intensity + 20 * noise);
                        
                        // 添加一些环境光遮蔽效果
                        const ao = 1.0 - Math.min(1.0, distance / 200);
                        r = Math.floor(r * ao);
                        g = Math.floor(g * ao);
                        b = Math.floor(b * ao);
                    }
                    
                    // 累积采样
                    const pixelIndex = (y * width + x) * 3;
                    pathTracingAccumulator[pixelIndex] += r;
                    pathTracingAccumulator[pixelIndex + 1] += g;
                    pathTracingAccumulator[pixelIndex + 2] += b;
                    
                    // 计算平均值
                    const avgR = pathTracingAccumulator[pixelIndex] / (pathTracingSamples + 1);
                    const avgG = pathTracingAccumulator[pixelIndex + 1] / (pathTracingSamples + 1);
                    const avgB = pathTracingAccumulator[pixelIndex + 2] / (pathTracingSamples + 1);
                    
                    // 设置像素颜色
                    const dataIndex = (y * width + x) * 4;
                    data[dataIndex] = Math.min(255, avgR);
                    data[dataIndex + 1] = Math.min(255, avgG);
                    data[dataIndex + 2] = Math.min(255, avgB);
                    data[dataIndex + 3] = 255;
                }
            }
            
            pathTracingSamples++;
            pathTracingCtx.putImageData(imageData, 0, 0);
            
            requestAnimationFrame(animatePathTracing);
        }
        animatePathTracing();
    </script>
</body>
</html>